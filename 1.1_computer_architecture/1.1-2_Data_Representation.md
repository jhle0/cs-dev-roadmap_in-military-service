# Data Representation (Binary, Two’s Complement, IEEE 754)

> Active recall
> 
> - Convert between **decimal ↔ binary (and hexadecimal)** by hand.
> - Create negatives with **two’s complement**, and explain **range, sign extension, overflow**.
> - State the **IEEE 754 single-precision** fields (sign/exponent/fraction) and the **value formula**.

## How numbers are represented with 0 and 1

- **Bit**: the smallest unit of information (0 or 1).
- **Byte**: 8 bits.
- **Word**: the amount of data a CPU processes at once (architecture-dependent).

### Binary (and Hex)

- Representing all numbers using only 0 and 1.
- **Place values**: …, $2^3$ = $8$ , $2^2$ = $4$, $2^1$ = $2$, $2^0$ = $1$
- **Decimal → Binary (division/remainder)**: 45 ÷ 2 → remainders reversed ⇒ `101101₂`.
- **Binary → Decimal**: `101101₂ = 32+8+4+1 = 45`.
- **Why hex?** Clean mapping: **4 bits ↔ 1 hex digit** (e.g., `1011₂ = B₁₆`).
    - Example: `0x3A = 0011 1010₂`.

### Two’s Complement

- The binary method to represent **negative integers**.
- **How to make a negative (must-memorize)**:
    1. **Invert bits**, then 2) **add 1**.
        
        Example (8-bit): `+18 = 0001 0010` → invert `1110 1101` → +1 → `1110 1110` = **−18**.
        
- **n-bit range**: $-2^{n-1} ~ 2^{n-1} -1$  (e.g., 8-bit: −128 ~ 127).
- **Sign detection**: look at the **MSB** (1 ⇒ negative).
- **Addition overflow rule**: adding **same-sign** operands but getting a **different-sign** result ⇒ overflow.
    - 8-bit example: `+100(0110 0100) + +50(0011 0010) = 150(1001 0110)` → MSB=1 (looks negative) ⇒ **overflow**.
    - CPUs expose **flags** (e.g., **OF/CF**) to **detect** overflow.

> Why two’s complement?
> 
> 
> One adder handles both add and subtract: a−b=a+(two’s(b))a - b = a + (\text{two’s}(b))a−b=a+(two’s(b)) → simpler hardware.
> 

### Fixed-Point

- Split integer and fractional parts at a **fixed position**.
    - Downsides: limited range, wasted space if the chosen split doesn’t fit values.
- Example: 5.625= 4 + 1 + 0.5 + 0.125 = $2^2$ + $2^0$ + $2^-1$ + $2^-3$ = 101.101(2)

### IEEE 754 Floating-Point (32-bit)

- “Floating” means the **binary point can move** via an exponent.
- Split into **fraction (mantissa) 23 bits** and **exponent 8 bits** (plus **sign**).

**Field layout (total 32 bits)**

- **Sign (S)**: 1 bit, **Exponent (E)**: 8 bits, **Fraction (F)**: 23 bits
- **Bias**: 32-bit **127**, 64-bit **1023**
- **Value (normalized)**:  $(−1)^S×(1.F)×2^{(E−Bias)}$

**Example: 5.75 → float32**

- **To binary**
    - Integer 5 → `101`
    - Fraction 0.75 → `0.11`
    - Combined: `101.11₂`
- **Normalize**: `1.0111 × 2²`
- **Fill fields**
    - Sign **S = 0** (positive)
    - Exponent **E = 2 + 127 = 129 = `1000 0001₂`**
    - Fraction **F =** bits after the leading `1.` ⇒ `0111` then pad 0s to 23 bits
- **Final bitstring**
    - `0 | 1000 0001 | 0111 0000 …` (total 23 fraction bits)

---

## How characters are represented with 0 and 1

- **Character set**: the set of symbols a computer can recognize and represent.

**1) ASCII**

- **7-bit (0–127)** legacy character set (control chars, English letters, digits, basic symbols).

**2) EUC-KR**

- Korean **legacy encoding** (covers most Hangul + some Hanja; not full Unicode).
- On Windows, **CP949 (UHC)** extended EUC-KR; today **UTF-8** is recommended for web/apps.

**3) Unicode & UTF**

- **Unicode (character set)**: assigns **code points** (e.g., U+AC00) to characters worldwide.
- **UTF (encoding)**: rules to convert code points to **bytes**.
    - **UTF-8**: 1–4 bytes (variable length), **fully ASCII-compatible** → default for web/files.
    - **UTF-16**: 2 bytes (or 4 via **surrogates**); has **endianness/BOM** concerns.
    - **UTF-32**: fixed 4 bytes; simple but storage-heavy (rare for storage/transport).
