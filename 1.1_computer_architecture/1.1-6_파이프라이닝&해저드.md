# 1.1-6 파이프라이닝 & 해저드

> Active recall
> 
> - 파이프라이닝이란?
> - 파이프라인에서 발생하는 세 가지 해저드는?
> - 각 해저드들의 해결 방법은?
> - 슈퍼스칼라? 비순차적 명령어 처리?

## 파이프라이닝(Pipelining)

- 명령어 실행 과정을 여러 단계로 나누어 여러 명령어를 겹쳐 실행하는 기법
- 목표 : CPU 처리량(Throughput)증가, 성능 향상
    - 일반적인 5단계 파이프라인 :
        1. IF(Instruction Fetch)
        2. ID(Instruction Decode)
        3. EX(Execute)
        4. MEM(Memory Access)
        5. WB(Write Back)

---

## 해저드(Hazard)

**Hazard : 명령어 파이프라인이 원활히 실행되지 못하고 지연되는 상황**

### 데이터 해저드

> 앞선 명령어 결과가 아직 안나왔는데, 뒤 명령어가 그 값을 필요로 할 때
> 
> - 해결 : Forwarding, Stall
> 
> **Forwarding**
> 
> - ALU 결과가 레지스터에 쓰이기 전에 바로 다음 명령어로 전달
> - Stall 없이 데이터 종속성 해결 가능
> 
> **Stall**
> 
> - CPU가 클럭 몇 사이클 동안 멈추고 기다림
> - 구현은 쉽지만 성능 저하 큼

### 제어 해저드

> 분기(Branch) 명령어 때문에 다음 명령어 흐름이 확정되지 않은 상황
> 
> - 해결 : Branch Prediction(분기 예측), Delayed Branch
> 
> **Branch Prediction**
> 
> - 명령이 분기하는지 미리 예측
> - Static Prediction, Dynamic Prediction
> 
> **Delayed Branch (지연 분기)**
> 
> - MIPS 등 초기 파이프라인 CPU에서 사용 → 분기 직후 명령어 1개를 무조건 실행

### 구조적 해저드

> 파이프라인 단계가 같은 자원(레지스터 파일, 메모리 등)을 동시에 요구할 때
> 
> - 해결 : 자원 복제, 자원 파이프라이닝
> 
> **자원 복제(Resource Duplication)**
> 
> - 메모리 하나에 Data, Instruction 을 담는 것이 아니라 Data 메모리, Instruction 메모리로 분리해 한 단계가 data를 접근할때 다른 단계에서는 Instruction에 접근 할 수 있게 함
> 
> **자원 파이프라이닝**
> 
> - 같은 자원을 여러 단계로 나눠 동시 접근 가능 하게 함
> 
> **⇒ 구조적 해저드는 현대 CPU에선 잘 안 나타남 → 대부분 자원 분리/복제로 해결되어 있음**
> 

## 심화 기법 (현대 CPU 필수 요소)

1. **슈퍼스칼라 (Superscalar)**
    - 한 클럭 사이클에 여러 명령어를 동시에 발행(issue)
    - CPU 내부에 ALU, Load/Store 유닛 등을 여러 개 배치
    - 예: x86, ARM Cortex-A 시리즈 대부분 슈퍼스칼라 구조
2. **비순차적 실행 (Out-of-Order Execution, OoO)**
    - 데이터 의존성이 없는 명령어들을 원래 순서와 상관없이 먼저 실행
    - 데이터 해저드로 인한 대기 최소화
    - 구현을 위해 **명령어 재정렬 버퍼(Reorder Buffer, ROB)**, **레지스터 리네이밍(Register Renaming)** 사용
3. **Speculation (추측 실행)**
    - 분기 예측을 기반으로 명령어를 미리 실행
    - 맞으면 성능 향상, 틀리면 파이프라인 Flush
    - 최근 CPU 취약점(Spectre, Meltdown)과 직결
4. **VLIW (Very Long Instruction Word)** – 심화 중 심화
    - 여러 연산을 하나의 긴 명령어에 넣어 병렬 실행
    - 컴파일러 의존적, 실무에서 범용 CPU는 잘 안 쓰고 DSP나 GPU에서 응용
