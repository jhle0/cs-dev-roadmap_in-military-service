# 1.1-7 CPU 성능 지표 & 명령어 집합 구조 (RISC vs CISC)

> Active recall
> 
> - CPU Time 공식?
> - RISC 와 CISC 각각의 특징?
> - 코어, 스레드, 하드웨어 스레드 ?

## 성능 지표 (Performance Metrics)

### 1. CPU Time (실행 시간)

- 프로그램이 CPU에서 얼마나 오래 실행되는지의 기본 공식:
    
    **CPU Time = Instruction Count × CPI × Clock Cycle Time**
    
    - **Instruction Count (명령어 수)**: 내가 작성한 코드가 얼마나 효율적인지에 따라 달라짐.
        
        (불필요한 루프, 비효율적인 알고리즘 → 명령어 수 ↑)
        
    - **CPI (명령어당 사이클 수)**: CPU 설계 특성과 명령어 종류에 따라 달라짐.
        
        (간단한 연산 = 1 사이클, 복잡한 연산 = 여러 사이클)
        
    - **Clock Cycle Time (클럭 시간)**: CPU 자체의 속도.
        
        (하드웨어 성능이 결정하는 부분, 개발자가 직접 바꿀 수는 없음)
        

⇒ 코드를 잘 짜서 Instruction Count를 줄이는 것 + CPU 특성에 맞게 작성해서 CPI가 낮은 연산을 쓰는 것이 중요

---

### 2. IPC (Instructions Per Cycle)

- **IPC = 1 / CPI**
- CPU가 한 클럭에서 얼마나 많은 명령어를 실행할 수 있는지.
- 최신 CPU는 파이프라이닝과 Superscalar로 IPC를 높이려고 함.

---

### 3. MIPS (Million Instructions Per Second)

- 초당 몇 백만 개의 명령어를 실행하는가.
- 단순 속도 지표지만, 명령어 종류마다 복잡도가 달라서 비교에는 부적절.
- **한계**: 명령어가 단순할수록 MIPS는 올라가지만, 실제로 프로그램 실행 속도가 빠르다고 보장할 수는 없음.

---

### 4. 성능에서 개발자가 신경쓸 부분

- **알고리즘 & 자료구조 선택** → Instruction Count에 직접적인 영향.
- **메모리 접근 패턴** → Cache 효율, CPI에 큰 영향.
- **병렬성 활용** (멀티스레드, SIMD 연산 등) → CPU의 IPC 활용 가능.

---

## 명령어 집합 구조 (ISA: Instruction Set Architecture)

ISA - CPU가 이해할 수 있는 명령어들의 모음

### 1. RISC (Reduced Instruction Set Computer)

- 특징: 명령어를 단순하고 규칙적으로 설계.
    - 모든 명령어 길이가 같음 (예: 32비트)
    - 연산은 대부분 레지스터끼리만 하고, 메모리 접근은 Load/Store로만 제한
- 장점: 파이프라이닝 쉽고, 하드웨어 단순 → 빠른 실행.
- 예: ARM, MIPS, RISC-V
- **개발자 관점**: 모바일/임베디드에서 ARM 많이 쓰이는 이유.

---

### 2. CISC (Complex Instruction Set Computer)

- 특징: 명령어 집합이 다양하고 복잡함.
    - 명령어 길이가 가변적 (1바이트~15바이트)
    - 명령어 하나로 여러 동작을 수행할 수도 있음 (예: 메모리+계산 동시에)
- 장점: 코드 밀도가 높음 (짧은 코드로 복잡한 연산 가능).
- 단점: 하드웨어 복잡, 파이프라이닝 어려움.
- 예: x86 (Intel, AMD)
- **개발자 관점**: PC 대부분이 x86이라 익숙한 환경.

---

## 코어(Core)와 스레드(Thread)

- **CPU Core (물리 코어)**
    - CPU 안의 “작업 단위” = 독립적으로 명령어를 해석하고 실행하는 처리 장치.
    - 듀얼코어, 쿼드코어 같이 여러 코어를 사용
    - 즉, 코어가 많으면 **동시에 여러 개의 명령어 흐름(프로세스/스레드)을 실행** 가능.
- **Thread (소프트웨어적 실행 단위)**
    - 하나의 프로세스가 여러 실행 흐름을 가질 수 있는데, 그 각각이 스레드.
    - 예: 브라우저 → 탭마다 스레드, 게임 → 그래픽/사운드/AI 스레드.
- **Hardware Thread (= 논리 코어, Hyper-Threading)**
    - 물리 코어 하나가 **레지스터/파이프라인 자원 일부를 복제해서 두 스레드를 동시에 처리**하는 기술.
    - 예: 인텔 하이퍼스레딩 → 4코어 CPU가 운영체제에서는 8개 논리 코어처럼 보임.
    - 실제 성능이 두 배는 아니고 보통 20~30% 정도 향상.
- **OS 관점**: 4코어 8스레드 CPU는 운영체제에서 "8개의 CPU"로 보임 → 스레드 스케줄링 단위로 사용됨.

---

## 멀티스레드 프로세서 (Multi-threaded Processor)

- 코어 자체가 여러 스레드를 지원하는 구조.
- **SMT (Simultaneous Multi-Threading)** = 여러 스레드가 같은 사이클에 ALU/파이프라인 자원을 공유해서 동시에 실행.
- 장점: 자원 유휴(idle) 시간 최소화 → 효율 ↑.
- 단점: 캐시 경쟁, 보안 취약점(Spectre 같은) 이슈 가능.
