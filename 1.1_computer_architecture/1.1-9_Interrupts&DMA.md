# 1.1-9 Interrupts & DMA

> Active Recall
> 
> - Be able to explain the step-by-step process of interrupt handling.
> - Be able to explain the role of the interrupt vector and the Interrupt Service Routine (ISR).
> - Be able to explain what context switching is and why it is needed.
> - Be able to compare the interrupt method and the DMA method.
> - Be able to explain how DMA improves CPU performance.

---

## 1. Interrupt

### (1) Concept

- **Definition**: While the CPU is executing instructions, if an **unexpected external request or event** occurs, the CPU temporarily suspends the current task and handles the request.
- In simple terms: the CPU says, *“Wait! Something more urgent came up—let’s handle this first.”*

---

### (2) Interrupt Handling Process

1. An I/O device or external device generates an **interrupt signal**.
2. The CPU finishes the current instruction, then **saves the current state (PC, registers) into the PCB (Process Control Block)**.
3. The CPU refers to the **Interrupt Vector** to jump to the corresponding Interrupt Service Routine (ISR, handler).
4. After executing the ISR, the CPU restores the saved context and resumes the original task.

→ In other words, this involves a **Context Switching** process.

> **Interrupt Vector**
> 
> - A table that stores the **starting address** of the ISR for each interrupt.
> - The CPU looks up this table using the interrupt number and jumps to the corresponding ISR.
> 
> **Interrupt Service Routine (ISR)**
> 
> - A specific **handler function** executed to handle an interrupt.
> - Example: keyboard input ISR, network packet receive ISR.
> 
> **Context Switching**
> 
> - The process in which the CPU suspends the currently running process, **saves its state to the PCB**, and switches to another process.

---

### (3) Types of Interrupts

- **Hardware Interrupts**: Keyboard input, mouse clicks, I/O completion, timer, etc.
- **Software Interrupts (Traps)**: Exception handling (e.g., divide by zero), system calls (requesting OS functions).

---

## 2. DMA (Direct Memory Access)

### (1) Concept

- Normally, I/O devices (disk, network card, etc.) transfer data to RAM via the CPU.
- With a **DMA controller**, however, I/O devices can transfer data **directly between the device and memory** without going through the CPU.
- This frees the CPU from repetitive “data copy” tasks, allowing it to focus on other computations.

---

### (2) DMA Operation Process

- The CPU instructs the DMA controller: *“Copy N bytes of data from this device into memory.”*
- The DMA controller handles the data transfer between the I/O device and memory.
    - During this process, DMA uses the **bus (address/data/control buses)** directly.
    - To avoid conflicts with the CPU, it uses **Cycle Stealing**—temporarily borrowing CPU cycles to transfer data.
- Once the transfer is complete, the DMA controller notifies the CPU with an **interrupt** (“Task complete!”).

---

### (3) Advantages of DMA

- Reduces CPU workload → improves overall system performance.
- Particularly effective for large data transfers (I/O-bound tasks such as disk reads, network packet transmission).
- Allows the CPU to perform other computations concurrently without waiting for I/O.

---

## 3. Interrupt vs DMA

| Category | Interrupt | DMA |
| --- | --- | --- |
| Concept | CPU handles external requests immediately | I/O device directly accesses memory |
| CPU Role | CPU intervenes for each request | CPU only intervenes at start and completion |
| Suitable For | Small tasks, event handling | Large data transfers |
| Processing | ISR execution (context switching occurs) | DMA controller transfers directly, notifies via interrupt |

---

## 4. Practical Examples

- **Interrupts**
    - Handling keyboard input (OS kernel looks up the ISR via the interrupt vector table).
    - Network packet arrival notification.
- **DMA**
    - A graphics card directly loading large texture data into memory.
    - SSD transferring data into RAM with minimal CPU involvement.
