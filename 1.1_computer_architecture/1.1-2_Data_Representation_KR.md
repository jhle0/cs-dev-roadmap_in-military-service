# 데이터 표현(2진수, 2의 보수, IEEE 754)


> Active recall
> 
> - 10진수 ↔ 2진수(및 16진수) 변환을 손으로 할 수 있다.
> - **2의 보수**로 음수를 만들고, 범위·부호확장·오버플로 개념을 말할 수 있다.
> - **IEEE 754** 단정도(32비트)의 필드(부호/지수/가수)와 값 계산식을 말할 수 있다.

## 0과 1로 숫자를 표현하는 방법

- 비트(bit) : 0과 1을 나타내는 가장 작은 정보 단위
- 바이트(byte) : 1byte = 8bit
- 워드(word) : cpu가 한 번에 처리할 수 있는 데이터 크기

### 이진수(그리고 16진수)

- 0과 1로만으로 모든 숫자를 표현하는 방법

- **자리값**: …, $2^3$ = $8$ , $2^2$ = $4$, $2^1$ = $2$, $2^0$ = $1$
- **정수 10→2**(나눗셈/나머지): 45 ÷2 → 나머지 역순 = `101101₂`.
- **2→10**: `101101₂ = 32+8+4+1 = 45`.
- **왜 16진수?** 2진수 4비트 ↔ 16진수 1자리 매핑이 깔끔(예: `1011₂ = B₁₆`).
    - 예: `0x3A = 0011 1010₂`.

### 2의 보수

- 이진수의 음수 표현 방법
- **음수 만드는 법**(절대 암기):
    - **비트 반전**(1↔0) → 2) **+1**
        
        예: 8비트 `+18 = 0001 0010` → 반전 `1110 1101` → +1 → `1110 1110` = **-18**
        
- **n비트 범위**: $-2^{n-1} ~ 2^{n-1} -1$ (예: 8비트는 -128 ~ 127)
- **부호 판정**은 **최상위 비트(MSB)**로 한다(1이면 음수).
- **덧셈 오버플로 규칙**: **같은 부호**끼리 더했는데 **결과 부호가 다르면** 오버플로.
    - 8비트에서 `+100(0110 0100) + +50(0011 0010) = 150(1001 0110)` → 최상위 비트 1(음수처럼 보임) ⇒ **오버플로**.
    - 따라서 오버플로 감지용으로 OF, CF 같은 플래그가 존재

> 왜 2의 보수가 좋은가?
> 
> 
> 같은 회로(덧셈기)로 **뺄셈을 덧셈으로 처리**(a + (−b))할 수 있어 하드웨어 단순화.
> 

### 고정 소수점 방식

- 정수부와 소수부로 고정으로 나누고 지정하여 처리하는 방식
    - 표현 가능한 범위가 매우 적어지는 단점
    - 낭비되는 공간이 많이 생김

- 예: 5.625 = 4 + 1 + 0.5 + 0.125 = $2^2$ + $2^0$ + $2^{-1}$ + $2^{-3}$
    - = 101.101(2)
    

### IEEE 754 부동소수점(32비트 기준)

- 소수점(point)이 둥둥 떠다닌다(floating)라는 의미
- 가수부 23bit, 지수부(8bit)로 나뉜다

- 필드 구성(총 32비트)
    - **부호 1비트(S)**, **지수 8비트(E)**, **가수 23비트(F)**
    - **Bias**: 32bit = **127**, 64bit = **1023**
    - **값(정규화 수)**: $(−1)^S×(1.F)×2^{(E−Bias)}$

- 예시: 5.75를 float32로
    - **이진수 변환**
        - 정수부 5 → `101`
        - 소수부 0.75 → `0.11`
        - 합치면: `101.11₂`
    - **정규화 (소수점 이동)**
        - `1.0111 × 2²`
    - **비트 채우기**
        - 부호 S = 0 (양수)
        - 지수 E = 2 + Bias(127) = 129 → `1000 0001₂`
        - 가수 F = 소수점 뒤 `0111 0000 0000 … (총 23비트)`
    - **최종 비트열**
        - `0 | 1000 0001 | 0111 0000 ...`

---

## 0과 1로 문자를 표현하는 방법

- 문자 집합 - 컴퓨터가 인식하고 표현할 수 있는 문자의 모음

**1) ASCII**

- **정의**: 초창기 **7비트(0–127)** 문자 집합. 제어문자 포함, 영문/숫자/기본 기호만.

**2) EUC-KR**

- **정의**: 한국어용 **레거시(과거) 인코딩**. 한글 대부분 + 일부 한자만 표현(전체 유니코드 커버 X).
- **참고**: Windows에선 **CP949(UHC)** 가 EUC-KR을 확장한 사실상의 표준이었어. 지금은 웹/앱에서 **UTF-8** 권장.

**3) 유니코드 & UTF**

- **유니코드(문자 집합)**: 전 세계 문자를 **코드 포인트**(각 문자에 부여한 번호)로 부여하는 표.
- **UTF(인코딩 방식)**: 코드 포인트를 **바이트**로 바꾸는 규칙.
    - **UTF-8**: 1~4바이트 **가변 길이**, **ASCII(0x00–0x7F)와 완전 호환** → 웹/파일 **기본 권장**
