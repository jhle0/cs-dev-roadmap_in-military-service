# 1.1-4 명령어 형식 & 주소 지정 방식

> Active recall
> 
> - 명령어 형식의 구성을 설명 할 수 있다.
> - **Immediate, Direct, Register, Displacement, Indirect, Stack** 지정방식을 설명 할 수 있다.

## 명령어 형식(Instruction Format)

- CPU 명령어는 보통 **연산 코드(OpCode)** + **오퍼랜드(Operand)**로 구성된다
    - **OpCode**: 어떤 연산을 할지 지정 (예: ADD, SUB, MOV)
    - **Operand**: 연산 대상 (데이터 or 주소)
    - **추가 필드**: 주소 지정 방식, 레지스터 번호 등이 들어갈 수 있음

⇒ CPU는 명령어 비트를 쪼개서 “무슨 연산 + 어떤 데이터”인지 이해함

---

## 주소 지정 방식

명령어의 오퍼랜드를 해석해 연산에 필요한 데이터를 어디서 가져올지 정하는 방법

- 즉, “데이터를 어떻게 찾을 것인가?”

### (1) Immediate (즉시 주소 지정)

- 명령어 자체에 데이터 값이 들어있음.
    - 가장 빠름 (메모리 접근 없음)
    - 단점: 표현 가능한 값이 명령어 길이에 제한됨
    

### (2) Direct (직접 주소 지정)

- 명령어 안에 **메모리 주소**가 직접 들어있음.
    - 단순하지만 명령어 크기가 커질 수 있음.
    - 실제 현대 CPU에서는 거의 쓰이지 않음
    

### (3) Indirect (간접 주소 지정)

- 명령어의 오퍼랜드가 **데이터 그 자체**가 아니라 **데이터가 놓인 주소를 담은 위치**를 가리킨다.
    - 즉, **주소의 주소**
    - 포인터 개념과 유사.

### (4) Register (레지스터 주소 지정)

- **오퍼랜드가 특정 레지스터를 지정**하고, 그 레지스터 안에 데이터가 들어있음
    - 속도가 매우 빠름 (메모리 접근 X).
    - 현대 CPU에서는 “레지스터 활용 최적화”가 성능 핵심

### (5) Displacement (변위 주소 지정)

- **기준 레지스터 + 오프셋(변위)**으로 주소를 계산해 메모리에 접근
    - 배열, 구조체, 지역 변수 접근에 사용
    - 매우 흔히 쓰임 (C 언어의 `arr[i]`, `struct.member`)

### (6) Stack (스택 주소 지정)

- **스택 포인터(SP, 또는 FP)를 암묵적으로 사용**해서 데이터를 읽고 쓰는 방식
    - ex. ADD -> top의 2개를 pop하여 더한다
    - 함수 호출, 지역 변수, 리턴 주소 저장에 필수.
