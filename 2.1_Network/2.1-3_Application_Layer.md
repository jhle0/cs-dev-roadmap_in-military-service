# 2.1–3 Application Layer

> Active recall
> 
> - What is the client–server architecture?
> - What is the P2P architecture?
> - What is a socket?
> - What is the biggest difference between TCP and UDP?
> - Why are timeouts/retries needed at the application level?
> - What is HTTP?
> - What does it mean that HTTP is stateless?
> - Why is the persistent connection (HTTP/1.1) important?
> - What is the purpose of cookies?
> - What is the purpose of a web cache (proxy)?
> - What is the role of SMTP?
> - What is the core role of DNS?
> - What is the advantage of P2P compared to client–server?
> - What is the key idea of DASH (adaptive streaming)?
> - What is the basic purpose of a CDN?
> - What is the difference between Enter Deep and Bring Home?

---

## 3.1 Principles of Network Applications

### Role of an application developer

- The **network core (routers/switches) only forwards** packets.
    
    → In situations like packet loss, delay, and congestion, **reliability, performance, and security must be handled by the developer**.
    
- What is handled at the application level:
    - **Timeout**: If there is no response, treat it as a failure after a certain time.
    - **Retry (exponential backoff)**: On failure, retry with increasing intervals.
    - **Circuit breaker**: If the server keeps failing, block requests and only retry at intervals.
    - **Caching**: Improve speed and reduce server load for repeated requests.
    - **TLS/HTTPS**: Encrypt data; ensure integrity and confidentiality.
    - **Authentication/authorization (OAuth, JWT)**: Verify who the user is and whether they have the right permissions.

### Application architectures

### 1) Client–Server

- An **always-on server (fixed IP/domain)**; client ↔ server communication (no client ↔ client).
- **Pros**: Easy centralized control/management; compliance-friendly.
- **Cons**: Server bottleneck/cost burden.
- **Examples**: Web services, online stores, REST/GraphQL APIs.

### 2) P2P

- Minimize reliance on a central server; peers communicate directly.
- **Self-scalability**: As users increase, upload resources increase as well, boosting total capacity.
    
    → “Distributing files to other peers adds service capacity” = each peer acts like a small server.
    
- **Challenges**: NAT/firewall issues, security/privacy, peer churn/free riders.
- **Examples**: BitTorrent, WebRTC file/video, blockchain.

### Processes & sockets

- **Process**: The unit of a running program for network communication.
    - **Client**: Starts communication (connection request).
    - **Server**: Waits and accepts client requests.
- **Socket**: Interface between the application and transport layers — the “network door” of a process.
    - **Addressing**: A specific process is identified by `(IP address, port number)`.
    - Server: Well-known ports (e.g., 80, 443, 25, 53).
    - Client: OS assigns an ephemeral port.
    - **TCP socket**: Connection-oriented, byte stream (no boundaries).
    - **UDP socket**: Connectionless, preserves message boundaries.

### Transport services available to applications

Applications use the **socket** to access the transport layer.

Transport protocols broadly provide four kinds of services:

1. **Reliable data transfer**
    - Guarantees data arrives without loss and in order.
    - Example: TCP provides it; UDP does not.
    - Loss-tolerant applications: Real-time video/audio (some loss is acceptable).
2. **Throughput**
    - Whether a certain rate (bps) can be guaranteed.
    - **Bandwidth-sensitive applications**: Multimedia, real-time voice calls (too low → unusable).
    - **Elastic applications**: Email, file transfer (slower is okay as long as it arrives).
3. **Timing**
    - Guarantee that data arrives within a certain time (e.g., within 100 ms).
    - Important for applications like real-time games and video conferencing.
4. **Security**
    - Encrypt at the sender and decrypt at the receiver.
    - TCP itself does not provide security → strengthened with TLS.

### Services actually provided by Internet transport protocols

1. **TCP (Transmission Control Protocol)**
    - **Connection-oriented**: Establish a connection via handshake before sending → transfer when ready.
    - **Reliable data transfer**: Byte stream arrives without loss/duplication and in order.
    - **Congestion control**: Automatically adjusts sending rate under network congestion.
2. **UDP (User Datagram Protocol)**
    - **Connectionless**: No handshake.
    - **Unreliable transfer**: No guarantees on loss/order.
    - **No congestion control**: Sends at the application’s pace regardless of network conditions.
        
        → Lower delay, but performance can actually degrade under congestion.
        

**→ Not provided by TCP and UDP**

- Guaranteed throughput; guaranteed timing.
- Therefore, real-time apps must be designed to tolerate delay themselves.

### Application-layer protocols

- **Definition**: Rules for how application processes on different end systems exchange messages.
    - Message types (request/response, etc.)
    - Syntax: Field structure and representation
    - Semantics: Meaning of each field
    - Rules: When and how to send messages and respond
- **Open standards**: HTTP, SMTP, DNS → defined in RFCs → anyone can implement
- **Proprietary protocols**: Some company-specific ones like Skype, Zoom → not public

---

## 3.2 The Web and HTTP

### HTTP overview

- **HTTP (HyperText Transfer Protocol)**: The core application-layer protocol of the Web
- Definition: Specifies message **format** and **exchange procedures** between client and server (RFC 1945, 7230, 7540, etc.)
- **Web page = a set of objects**
    - Base HTML + images, CSS, JS, etc.
    - Each object is identified by a **URL (Uniform Resource Locator)**
    - URL structure: `http://www.school.edu/picture.gif`
        - Host: `www.school.edu`
        - Path: `picture.gif`
- **Web browser = HTTP client**, **Web server = HTTP server**
    - Client sends request messages
    - Server sends response messages

**Characteristics**

- HTTP is **TCP-based (default port 80, HTTPS is 443)**
- Because TCP provides **reliability (lossless, in-order delivery)**, HTTP can operate without worrying about it
- **Stateless protocol**: Server does not store client state (supplemented with cookies/sessions)

### Nonpersistent vs. persistent connections

**Nonpersistent (HTTP/1.0)**

- A separate TCP connection for each request/response pair
- Flow: Request HTML → response → connection close → new connection for additional objects
- Response time: **2 RTT + transmission time**
- **Cons**
    - New connection per object → TCP buffer/variable overhead
    - Costs 2 RTT each time

**Persistent (HTTP/1.1, default)**

- Keep the TCP connection after a response
- Subsequent requests/responses use the same connection
- **Pipelining**: Send multiple requests in a row without waiting for the previous response
- Server closes the connection after an idle timeout

### HTTP message format

**Request message**

```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr

```

- **Request line**: Method (GET, POST, HEAD, PUT, DELETE, etc.) + URL + HTTP version
- **Header lines**: Host, Connection, User-agent, Accept-language, etc.
- **Entity body**: Typically used with POST

**Response message**

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
(data data data...)

```

- **Status line**: Version, status code, status message
- **Header lines**: Connection, Date, Server, Last-Modified, Content-Length, Content-Type
- **Examples of status codes**:
    - 200 OK
    - 301 Moved Permanently
    - 400 Bad Request
    - 404 Not Found
    - 505 HTTP Version Not Supported

### Cookies

- HTTP is stateless → server cannot directly track client state
- **Cookies = a way to maintain state (compensate for statelessness)**
- How it works
    1. Server creates an identifier and records it in a DB
    2. Includes `Set-Cookie` header in the response
    3. Browser stores it in a cookie file
    4. On reconnecting to the same server, sends `Cookie: <id>` header → server identifies the user

**Uses**: Keep login sessions, personalize per user, ad tracking

### Web caching (proxy)

- **Web cache/proxy server**: An entity that satisfies HTTP requests on behalf of web servers
- **How it works**
    1. Browser sends request to the cache
    2. If the cache has the object, it responds immediately
    3. If not, it requests the origin server, stores the result, and serves the client
- **Benefits**
    - Shorter response time (fast LAN between client and cache)
    - Reduce an organization/ISP’s outbound traffic
    - Reduce Internet-wide traffic → overall performance improvement

> A cache acts as both a client and a server.
> 
- **Conditional GET**: Solves the issue that a cached copy **may be stale** → ensures freshness
    - Request includes `If-Modified-Since` header
    - If the server object hasn’t changed, it responds with `304 Not Modified`

### HTTP/2 and HTTP/3

**HTTP/1.1 problem**

- **HOL (Head-of-Line) blocking** on a single TCP connection
    
    → If the front request is delayed, subsequent requests are delayed in a chain
    
- Workaround: Browsers open multiple TCP connections in parallel
    
    → But this is **inefficient** due to connection management/resource overhead
    

**HTTP/2**

- **Framing**: Split data into small frames and **interleave** frames from multiple requests; reassemble on arrival → mitigates HOL
- **Binary encoding**: Process messages in binary instead of text → better parsing, fewer errors
- **Message prioritization**: Prioritize important resources (CSS, JS, etc.)
- **Server push**: When the client requests HTML, the server can **pre-send** needed CSS/JS

**HTTP/3**

- Switch the transport from TCP to **QUIC (UDP-based)**
- Advantages:
    - **0-RTT connection**: On reconnection, send data without a handshake
    - **Improved congestion control**: More efficient than TCP under congestion
    - **Fast packet loss recovery**: Stream-level delivery → a single lost packet doesn’t block the entire connection
    - **Mobile optimization**: Maintains connections when switching Wi-Fi ↔ LTE

---

## 3.3 Internet Email (SMTP/IMAP/POP3)

### Components

- **UA (User Agent)**: Client app/webmail
- **Mail server**: Stores mailboxes, manages queues
- **Transfer**: **SMTP** (server ↔ server)

### SMTP (Simple Mail Transfer Protocol)

> The main application-layer protocol for Internet email
> 
- Uses TCP to send/receive between mail servers
- Also uses persistent connections
- Consists of a `header` (with metadata) and `message body`

### Mail access protocols

If the mail server were on a local host, that host would need to be always on — unrealistic.

- Instead, receive mail in a mailbox stored on a shared mail server that is always on
- The client’s user agent does not talk directly to the recipient’s mail server

SMTP is a `push` protocol, whereas retrieving messages is a `pull` action, so other protocols are used:

- `HTTP`
    - Used for web-based email or smartphone apps
    - Naturally, the mail server needs both an SMTP interface and an HTTP interface
- `IMAP`: Internet Message Access Protocol defined in RFC 3501

---

## 3.4 DNS (Domain Name System)

### Overview

- **Role**: Convert human-readable **hostnames** ↔ **IP addresses** understood by routers
- **Structure**: A globally distributed **hierarchical name server system** + application-layer protocol (UDP 53)
- **Characteristics**: **UDP-based** for fast responses (use TCP when needed); **caching** to minimize latency

### Main services

- **Hostname → IP address** resolution
- **Host aliasing**: Alias (CNAME) ↔ canonical hostname
- **Mail server aliasing**: Support simplified mail addresses via MX records
- **Load distribution**: Rotate among multiple server IPs to distribute traffic

### DNS server hierarchy

1. **Root servers**: Over a thousand worldwide; provide TLD server addresses
2. **TLD servers**: Manage top-level domains like `.com`, `.org`, `.kr`
3. **Authoritative servers**: Managed by domain owners; hold final records for the domain
4. **Local DNS servers**: Operated by ISPs/organizations; speed up responses via caching

### How it works

1. Application calls the DNS client → queries a hostname
2. Request goes to the local DNS server → searches through Root/TLD/Authoritative in order
3. Returns the final IP address → stores it in cache
- **Recursive query**: An upper server queries on behalf of the client
- **Iterative query**: An upper server returns “the next server’s address” only
- In practice, a mix is used

### Resource Records (RRs)

Format: `(Name, Value, Type, TTL)`

- **A**: hostname → IPv4 address
- **AAAA**: hostname → IPv6 address
- **NS**: domain → authoritative name server
- **CNAME**: alias hostname → canonical hostname
- **MX**: mail server address

### DNS message structure

- **Header**: Identifier, flags (Q/R, recursion, etc.), count fields
- **Question**: Query name, type (A, NS, MX, etc.)
- **Answer**: Query results (records)
- **Authority**: Other authoritative server info
- **Additional**: Extra useful info (e.g., A record of the MX host)

### Security & vulnerabilities

- **DDoS attacks**: Bandwidth flooding against root/TLD servers
- **DNS cache poisoning**: Insert fake records → redirect users to attacker servers
- **DNSSEC**: Digital signatures to ensure record integrity

---

## 3.5 P2P File Distribution

> The P2P architecture minimally relies on always-on infrastructure servers, and intermittently connected host pairs (peers) communicate directly with each other.
> 

### Client–Server model

- The server sends every copy of the file directly to each client.
- **Problem**: Due to server bandwidth limits, as the number of clients (N) grows, server load scales linearly → poor scalability.

### P2P model

- A peer that receives a piece of the file can upload it to other peers.
- In other words, the server doesn’t do all the sending — **all peers share the server’s role** to some extent.
- **Self-scalability**: As more peers join, total upload capacity grows, speeding up distribution.
- Drawbacks: NAT/firewall, security, and peer churn issues.

### <BitTorrent>

### Torrent

- A **group of peers** sharing a specific file is called a torrent.
- The file is split into **chunks** (typically 256 KB) and transferred.
- A peer uploads to others while downloading chunks.
- A peer that completes the file may leave or remain as a **seeder** to upload.

### Tracker

- An infrastructure server that tracks torrent participants.
- When a new peer joins, the tracker returns a random subset of peers’ IPs → the new peer starts connecting to them.
- The set of neighboring peers changes over time (churn).

### Exchange strategies

1. **Rarest first**
    - Among chunks it doesn’t have, request those **least common** among neighbors first.
    - Spreads rare chunks early so the file is evenly distributed across the network.
2. **Tit-for-tat**
    - Preferentially upload to peers that upload to you the fastest.
    - A reciprocal incentive: peers that upload more get more download opportunities.
    - Focus on four main peers for upload and occasionally give new peers a chance to expand trading relationships.

---

## 3.6 Video Streaming & CDN

### Internet video

- Video is a sequence of 24–30 frames (images) per second.
- **Compression is essential**: Bitrate and quality are inversely related → lower bitrate = lower quality, higher bitrate = higher quality.
- Typical streaming rates: 100 kbps to several Mbps; 4K is 10 Mbps or more.
- For stable playback, **network throughput ≥ video bitrate** is needed.
- A single video is encoded into multiple quality versions.

### HTTP streaming & DASH

- Video is stored as files on an HTTP server → the client requests via **HTTP GET**.
- The client stores downloaded data in a **buffer → starts playback when sufficient data accumulates**.
- Problem: Receives the same quality regardless of network conditions.

**DASH (Dynamic Adaptive Streaming over HTTP)**

- Store **multiple quality versions** of the video.
- The client requests **each chunk** at a different quality depending on network conditions.
- **Manifest file**: Lists URLs for each version.
- Result: High quality when bandwidth is ample; low quality when scarce — automatically.

### CDN (Content Delivery Network)

- Problems when serving from a single data center:
    1. Long distance causes link bottlenecks.
    2. Popular videos incur heavy duplicate transfer costs.
    3. A single failure can stop the entire service.

**Solution → CDN**

- Operate distributed server clusters across regions; store content replicas.
- Users fetch content from the nearest (or best-performing) CDN server.

**Server placement strategies**

- **Enter Deep**: Deploy servers deep into ISP access networks (Akamai). → Lower latency, higher management cost.
- **Bring Home**: Deploy large clusters at major hubs (IXP, etc.) (Limelight). → Easier maintenance, lower cost, somewhat higher latency.

**Caching methods**

- **Pull**: Fetch on demand and cache; unpopular content is evicted automatically.
- **Push**: Preload content to CDN servers in advance (e.g., Netflix).

**DNS redirection**

- CDN intercepts DNS responses and returns the IP of the “best server” to the user → the client connects to that CDN server.
- Cluster selection criteria: geographic distance, RTT (latency), packet loss rate, server load, etc.

### Case studies

**Netflix**

- Process/encode video in AWS → upload to CDN.
- Operates its own CDN (racks inside IXPs/ISPs).
- **Push caching**: Distribute popular content to ISP/IXP caches daily in advance.
- Uses custom software to choose optimal servers instead of plain DNS redirection.

**YouTube**

- Uses Google’s own CDN.
- Picks the server with the lowest RTT by default, reassigns based on load.
- Uses HTTP streaming; users can select quality manually.
- Uses **byte-range requests** to download only needed parts → reduces waste.

---

## 3.7 Socket Programming

### Overview

- A network application = **client program + server program**
- Two processes read/write messages through sockets
- **Socket**: Interface between the application and transport layers (the network door)
- Developers choose **TCP vs UDP** based on application needs

### UDP socket programming

- UDP: **Connectionless**, simple and fast
- Sender puts **destination IP + port number** in the packet and sends
- Receiver gets the packet and **parses/handles** the content

**Code flow**

- Client:
    1. Create socket (UDP)
    2. Read user input
    3. Send with `sendto()` (message + destination address)
    4. Receive server reply → print to screen
- Server:
    1. Create socket + bind to port
    2. In a loop, wait on `recvfrom()` for packets
    3. Process received data (e.g., convert to uppercase)
    4. Reply with `sendto()`

### TCP socket programming

- TCP: **Connection-oriented**, reliable
- Establish a connection via a **3-way handshake** before communication
- Server uses two kinds of sockets:
    - **Welcome socket**: Waits for client connection requests
    - **Connection socket**: Handles data exchange with a specific client

**Code flow**

- Client:
    1. Create TCP socket
    2. `connect()` to server IP/port
    3. Enter a string and `send()`
    4. Receive server response and print
    5. `close()` to end the connection
- Server:
    1. Create TCP socket + bind to port
    2. `listen()` for connections
    3. `accept()` a connection → create a connection socket
    4. Receive client request and process (e.g., convert to uppercase)
    5. Send response, then close the connection socket (welcome socket stays open)
