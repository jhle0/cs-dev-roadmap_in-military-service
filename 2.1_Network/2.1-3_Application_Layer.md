# 2.1-3. Application Layer

> Active recall
> 
> - Explain in one line the differences, pros/cons, and examples of client–server vs. P2P architectures
> - Describe the role of a socket (interface between application and transport) and the difference between TCP/UDP
> - Explain the key characteristics of HTTP (Stateless, transport layer), and differences among HTTP/1.1, 2, and 3
> - Outline the HTTP request/response structure, methods and idempotency, representative status codes, cookies/sessions/tokens, and cache headers
> - Explain the roles of SMTP/IMAP/POP3 and the security mechanisms SPF/DKIM/DMARC/STARTTLS in email
> - Describe DNS hierarchy and query flow, records (A/AAAA/CNAME/NS/MX/TXT), UDP/TCP/EDNS0, DNSSEC, and DoH/DoT
> - Explain BitTorrent’s chunk/rarest-first/tit-for-tat, DHT, and NAT traversal (STUN/TURN/ICE) in P2P systems
> - Describe socket server aspects such as blocking vs. non-blocking, select/epoll, Nagle/Delayed ACK, and TIME_WAIT
> - Explain streaming concepts: ABR (DASH/HLS) and CDN (cache key/invalidation/latency-based routing)

---

## 3.1 Principles of Network Applications

### Role of the Application Developer

- **The network core (routers/switches) only forwards packets**
    
    → In the presence of packet loss, delay, or congestion, **reliability, performance, and security must be handled by the developer**
    
- At the application level, developers are responsible for:
    - **Timeouts**: Fail if no response arrives within a set period
    - **Retries (exponential backoff)**: Retry with increasing intervals to avoid overload
    - **Circuit breakers**: Stop sending requests when the server is repeatedly failing, retry only after intervals
    - **Caching**: Store responses to avoid redundant requests and reduce load
    - **TLS/HTTPS**: Ensure encryption, integrity, and confidentiality
    - **Authentication/Authorization (OAuth, JWT)**: Verify identity and permissions

### Application Architectures

### 1) Client–Server

- A server is **always running** with a fixed IP/domain; communication occurs client↔server (not client↔client)
- **Pros**: Centralized control and easy management, compliance-friendly
- **Cons**: Server bottleneck and higher operational costs
- **Examples**: Web services, e-commerce platforms, REST/GraphQL APIs

### 2) Peer-to-Peer (P2P)

- Minimizes central dependency, peers communicate directly
- **Self-scalability**: As the number of users increases, total upload capacity also increases
    
    → “Distributing files among peers adds service capacity” = each peer partially acts as a server
    
- **Challenges**: NAT/firewall traversal, security/privacy, peer churn, and free-riders
- **Examples**: BitTorrent, WebRTC (file/video), blockchain networks

### Processes & Sockets

- **Process**: A running program is the unit of communication
    - **Client**: Initiates communication (connection request)
    - **Server**: Waits and accepts client requests
- **Socket**: Interface between the application layer and transport layer; the “door” of a process to the network
    - **Addressing**: Combination of `(IP address, port number)` identifies a process
    - Server: Uses a well-known port (e.g., 80, 443, 25, 53)
    - Client: OS assigns an ephemeral port (temporary port number for the session)
    - **TCP socket**: Connection-oriented, byte stream (no message boundaries)
    - **UDP socket**: Connectionless, message-oriented (datagram boundaries preserved)

### Transport Services Available to Applications

Applications access the transport layer via sockets

Transport protocols can provide four key services:

1. **Reliable data transfer**
    - Guarantee that data arrives without loss and in order
    - Example: Provided by TCP, not by UDP
    - Loss-tolerant applications: real-time audio/video (occasional loss acceptable)
2. **Throughput**
    - Guarantee of a minimum rate (bps)
    - **Bandwidth-sensitive applications**: multimedia, VoIP (require sufficient throughput)
    - **Elastic applications**: email, file transfer (can tolerate low throughput)
3. **Timing**
    - Guarantee delivery within a specific time bound (e.g., <100 ms)
    - Crucial for real-time games, video conferencing
4. **Security**
    - Encryption/decryption of data between sender and receiver
    - TCP itself does not provide security → strengthened by TLS

### Services Actually Provided by Internet Transport Protocols

1. **TCP (Transmission Control Protocol)**
    - **Connection-oriented**: Handshake before communication, then full-duplex data transfer
    - **Reliable data transfer**: Ensures ordered, loss-free, duplicate-free byte stream delivery
    - **Congestion control**: Adjusts sending rate when the network is congested
2. **UDP (User Datagram Protocol)**
    - **Connectionless**: No handshake
    - **Unreliable transfer**: No guarantee of delivery or order
    - **No congestion control**: Sends at application’s rate, but congestion can still cause loss and lower throughput
        
        → Lower latency, but performance may degrade under congestion
        

**→ What TCP and UDP do NOT provide**

- Throughput guarantees
- Timing guarantees
    
    → Applications sensitive to delay must be designed to handle variability
    

### Application Layer Protocols

- **Definition**: Rules for how application processes on different end systems exchange messages
    - Message types (request, response, etc.)
    - Syntax: structure and fields of the messages
    - Semantics: meaning of each field
    - Rules: when and how to send and respond to messages
- **Open standards**: HTTP, SMTP, DNS (defined in RFCs, ensuring interoperability)
- **Proprietary protocols**: Skype, Zoom, etc., closed and not publicly specified
