# 2.1-4 Transport Layer

> Active Recall
> 
> - What is the **main role** of the transport layer?
> - What is the **difference** between the transport layer and the network layer?
> - What are the functions of **multiplexing** and **demultiplexing**?
> - What are the **fundamental differences** between TCP and UDP?
> - What fields make up the **TCP segment structure**?
> - How is **Reliable Data Transfer (RDT)** implemented in principle?
> - What is the difference between **GBN (Go-Back-N)** and **SR (Selective Repeat)** protocols?
> - What do **flow control** and **congestion control** in TCP each manage?
> - How do **Slow Start**, **Congestion Avoidance**, and **Fast Recovery** operate?
> - Why was the **QUIC protocol** introduced, and how does it differ from **TCP**?

---

## 4.1 Transport Layer Services and Overview

### Role of the Transport Layer

- Provides **logical communication between processes** running on different hosts
- Operates **above the network layer (IP)**, extending IP’s “**host-to-host delivery**” to “**process-to-process delivery**”
- Works **only at the end systems** — routers do not process transport-layer data

### Operational Concept

- **Sender side**: divides application data into **segments**, adds headers, and passes them to the IP layer
- **Receiver side**: reassembles segments delivered by IP and sends the data to the appropriate process
- Responsible for **reliability, error recovery, and ordering** of data

### Relationship with the Network Layer

| Category | Network Layer (IP) | Transport Layer (TCP/UDP) |
| --- | --- | --- |
| Communication Unit | Host ↔ Host | Process ↔ Process |
| Operation | Present in all routers | Operates only in end systems |
| Service | Unreliable (best-effort) | TCP: Reliable / UDP: Unreliable |
- Transport-layer services are **limited by the network layer’s capabilities** (no delay or bandwidth guarantees)
- TCP provides reliability over unreliable IP through **error detection and retransmission**

### Main Protocols

| Protocol | Characteristics | Typical Use Cases |
| --- | --- | --- |
| **TCP** | Reliable, connection-oriented, flow/congestion control | HTTP, FTP, SMTP |
| **UDP** | Unreliable, connectionless, low delay | Streaming, gaming, DNS |

### IP Service Model

- **Best-effort delivery**
    
    → No guarantees of **delivery, order, or integrity**
    
- TCP builds **Reliable Data Transfer (RDT)** on top of this best-effort service

---

## 4.2 Multiplexing & Demultiplexing

### Concept

- **Multiplexing**: The process of gathering data from multiple application processes and sending them through the network.
- **Demultiplexing**: The process of delivering received segments to the **correct socket (process)**.
- In other words, it extends **“host-to-host delivery”** into **“process-to-process delivery.”**

### Basic Operations of the Transport Layer

1. **On the receiving side**
    - Receives a segment from the network layer
    - Checks the segment’s **header fields (e.g., port numbers)**
    - Delivers data to the appropriate socket (**demultiplexing**)
2. **On the sending side**
    - Collects data from multiple sockets
    - Adds headers containing **source and destination port numbers**
    - Encapsulates the data into segments and passes them to the network layer (**multiplexing**)

### UDP Multiplexing / Demultiplexing

- A UDP socket is identified by a **2-tuple: (Destination IP, Destination Port)**.
- Segments with the same destination IP and port are delivered to the **same socket**.
- The **source port number** serves as a return address for replies.

> Example: In a DNS query (UDP port 53), the client opens a temporary port,
> 
> 
> and the server responds to **destination port 53** on the client’s request.
> 

### TCP Multiplexing / Demultiplexing

- A TCP connection is identified by a **4-tuple: (Source IP, Source Port, Destination IP, Destination Port)**.
- This means multiple clients can connect to the **same server port (e.g., 80)** simultaneously,
    
    since each connection has a unique 4-tuple.
    

> Example: A web server listens on port 80,
> 
> 
> but each client connection uses a different combination of source IP and port,
> 
> allowing multiple sessions to coexist concurrently.
> 

### Example of TCP Connection Establishment

1. The client creates a TCP socket and sends a **connection request (SYN)**.
2. The server accepts the request through a **well-known port (e.g., 80)**.
3. Once established, the server creates a new **connection socket**
    - Identifier: (Client IP, Client Port, Server IP, Server Port)
4. Subsequent data is delivered through that connection socket (**demultiplexing**).

### Multiple Connections in a Web Server

- Even if multiple clients connect to the **same server port (80)**,
    
    each connection is treated separately because the **source IP/port pairs differ**.
    
- High-performance servers handle multiple connections using **threads** or **asynchronous event loops** for efficiency.

---

## 4.3 Connectionless Transport: UDP (User Datagram Protocol)

### Concept

- **UDP** provides the **simplest form of transport-layer service**.
- Adds only minimal functionality on top of IP — mainly **multiplexing/demultiplexing** and **basic error checking**.
- **Connectionless:** No handshake before transmission, no connection state maintained.

### Operation

1. The application process generates a message.
2. A segment is created with **source and destination port numbers** added.
3. The segment is passed to the IP layer, **encapsulated into a datagram**, and sent.
4. The receiver delivers the segment to the correct **socket** based on the destination port number.

> UDP follows a “send and forget” model —
> 
> 
> there is no connection setup or congestion control, resulting in **minimal delay**.
> 

### Advantages of UDP

- **Fast transmission:** No 3-way handshake before sending.
- **Low latency:** Data is sent immediately to the IP layer.
- **Small header overhead:** 8 bytes (compared to TCP’s 20 bytes).
- **Stateless:** The server can handle many clients simultaneously.
- **Application-level control:** Applications can implement their own reliability or congestion control if needed.

> Examples: DNS, streaming, online gaming, VoIP, QUIC
> 

### Disadvantages of UDP

- **No congestion control** → risk of network overload.
- **No reliability** → no guarantee of delivery or order.
- **No error recovery** → checksum detects errors but does not fix them.

> If many UDP senders transmit at once, TCP traffic may be suppressed,
> 
> 
> leading to **fairness issues** in bandwidth sharing.
> 

### UDP Segment Structure

| **Source Port #** | **Destination Port #** |
| --- | --- |
| **Length** | **Checksum** |
| **Application Data (Message)** |  |

> Total UDP header size: 8 bytes (fixed)
> 
> 
> Much simpler than TCP, containing only minimal control information.
> 

### UDP Checksum

- The sender adds all 16-bit words and takes the **one’s complement**.
- The receiver repeats the calculation:
    - If the result is `1111111111111111`, the segment is valid.
    - If any `0` appears, an error is detected.
- Errors are **detected but not corrected** — retransmission is left to higher layers.

### Extending UDP Reliability

- UDP itself is unreliable, but **applications can implement reliability on top of it.**
    
    → Example: Google’s **QUIC**
    
    - Runs **over UDP**
    - Implements its own **retransmission, congestion control, and encryption**
    - Serves as the transport foundation for **HTTP/3**
