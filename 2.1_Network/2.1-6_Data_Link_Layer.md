# 2.1–6 Data Link Layer

> Active recall
> 
> - Explain in your own words the role of the data link layer and how it relates to the network layer.
> - What is framing and why is it necessary?
> - How do error detection and correction work at the data link layer?
> - Why do collisions occur in a multiple-access environment, and what approaches are used to handle them?
> - Explain why a switch is different from a hub.
> - Describe, step by step, how a switch “self-learns” MAC addresses.
> - Why is it a problem if a loop forms in a switched network?
> - Explain the need for VLANs and how they work in your own words.
> - How is MPLS different from traditional IP forwarding?
> - Describe a data center network structure (ToR–Aggregation–Core) as if you were drawing it.
> - When requesting a web page, in what order do the different layers actually operate?

## 6.1 Introduction to the Data Link Layer

### Role of the Data Link Layer

- The **Data Link Layer** is responsible for data transfer between **two directly connected nodes (a single hop)**.
- When the upper layer (the network layer) creates an IP packet, the data link layer encapsulates it into a **frame** and sends it.
- A frame consists of a **header (control information)** and **data (the IP packet)**.
- In reality, communication proceeds as “source host → multiple links → destination host”.
    
    For each link along the path, its own data link layer protocol operates independently.
    

### Services Provided by the Data Link Layer

1. **Framing**
    - Wraps an IP datagram inside a frame for transmission.
    - A frame includes not just the data but also the sender/receiver addresses (MAC) and error-detection bits.
2. **Link Access Control (MAC Protocol)**
    - When multiple nodes share a single medium, it coordinates **who can send, and when**.
        - A medium access control protocol specifies the rules for sending frames onto the link.
    - On point-to-point links, the rule can be as simple as “if the link is idle, send”.
    - On broadcast links, you need **collision-avoidance/-handling mechanisms (e.g., CSMA/CD)**.
3. **Reliable Delivery**
    - On error, the link may perform **retransmission at the link level** or use **ACK/NACK** to confirm delivery.
    - This is mainly used on error-prone links, such as wireless links.
    - On most wired LANs (Ethernet), this is often omitted because TCP takes care of reliability.
4. **Error Detection and Correction**
    - Noise and signal attenuation during transmission can cause bit errors.
    - The sender appends error-detection bits; the receiver checks them.
    - This is usually done in hardware (the NIC) using **CRC (Cyclic Redundancy Check)**.
    - Some protocols can even locate the error bits and perform **correction**.

### Where the Data Link Layer Is Implemented

- **Network Interface Controller (NIC, Network Interface Card / Adapter)**
    - Most data link layer functions are implemented in the hardware **network adapter (NIC)**.
    - Sending NIC: encapsulates datagrams stored in memory into frames and transmits them.
    - Receiving NIC: receives frames, extracts the IP datagram, and passes it up to the higher layer.
- **Controller**
    - Inside the NIC, the controller is a dedicated chip where data link services are implemented.
    - Framing, transmission, and error detection are handled in hardware.
- **CPU and Software Components**
    - Some data link functions are implemented in software and run on the CPU.
    - Examples: address management, error handling, controller initialization, and data-delivery coordination.

---

## 6.2 Error Detection and Correction

### Overview

- At the data link layer, **error detection** and **error correction** are used to detect bit corruption that may occur during transmission.
- In most cases, this is handled automatically by **hardware (the NIC)**; corrupted frames are **dropped** and never passed up to higher layers like TCP.

### Parity Checking

- Add a single **parity bit (1 bit)** to the data so that the number of 1s becomes either even or odd.
- It can only perform **simple error detection**, and it cannot detect errors when an even number of bits are flipped.
    - If two bits are corrupted, the parity may still look “correct,” so the error goes undetected.

### Checksum Method

- The data is divided into fixed-size blocks, which are then added together.
    
    The **one’s complement** of this sum is stored in the header.
    
- The receiver recomputes the sum, and if the result is **all 1s**, the data is considered valid; otherwise, an error is assumed.
- This method is used in **TCP/UDP headers** to detect data corruption during transmission.
- It is implemented in software and has **lower detection accuracy than CRC**.

### Cyclic Redundancy Check (CRC)

- CRC is the most widely used error-detection method at the data link layer. The 4-byte FCS (Frame Check Sequence) at the end of an Ethernet frame is the result of a CRC.
- The sender treats the bit string to be sent as a large binary number, divides it by a predefined **generator polynomial (G)**, and appends the remainder to the end of the data. This remainder is the CRC code.
- The receiver divides the entire received bit string by the same polynomial. If the remainder is 0, it assumes that no bit errors occurred during transmission; otherwise, it treats the frame as corrupted and discards it.
- All of this is implemented as binary division using XOR operations, which makes CRC very easy to implement in hardware. Dedicated CRC circuits are built into the NIC, so the CPU does not have to get involved.
- A well-designed CRC can detect:
    - Single-bit errors
    - Short burst errors
    - Most random patterns of bit corruption
    
    with very high probability.
    
- Ethernet typically uses **CRC-32**, a 32-bit code, which makes the probability of undetected errors extremely small.
- The key point is that CRC is about **detecting** errors, not **fixing** them. When the receiving NIC detects an error, it simply discards the frame; recovery from loss is handled by upper layers such as TCP.

---

## 6.3 Multiple Access Links and Protocols

### Two Types of Network Links

- **Point-to-Point Link**
    
    A connection where two devices exclusively use a single channel.
    
    Examples: PPP, HDLC
    
- **Broadcast Link**
    
    A structure where multiple nodes share a single channel and can transmit over it.
    
    Examples: Ethernet, wireless LAN
    

### The Multiple Access Problem

In a broadcast environment, if multiple nodes transmit at the same time, **collisions** occur.

When a collision happens, frames are corrupted and must be retransmitted, which leads to **wasted bandwidth**.

To handle this, we use **Multiple Access Protocols (MAPs)**.

- Two properties required of a good MAP:
    - If there is only one node, it should be able to transmit at the **full rate R bps**.
    - If there are M nodes, each should effectively get about **R/M bps** on average.

### Channel Partitioning Protocols

**Time Division Multiplexing (TDM)**

- Divides the channel into time slots and lets each node transmit **in turn**.
- No collisions; fair by design.
- Drawback: Time slots are wasted when a node has nothing to send.

**Frequency Division Multiplexing (FDM)**

- Splits the channel bandwidth into multiple **frequency bands** and assigns each band to a node.
- Has similar pros and cons to TDM.

**Code Division Multiple Access (CDMA)**

- Assigns each node a unique **code**, allowing simultaneous transmission.
- As long as the codes have low cross-correlation, multiple nodes can transmit in parallel without collisions.
- Widely used in wireless communication (Wi-Fi, 3G) and military systems.

### Random Access Protocols

- Whenever a node transmits, it sends at the **full rate R bps**.
- If a collision occurs, nodes wait for a random amount of time and then retransmit.

**Slotted ALOHA**

- Time is divided into slots; transmissions must start at slot boundaries.
- On collision, the node retries after a random number of slots.
- Maximum efficiency: about **37%**.

**Pure ALOHA**

- No time-slot structure; nodes start transmission at arbitrary times.
- Higher collision probability than Slotted ALOHA.
- Maximum efficiency: about **18%**.

**CSMA (Carrier Sense Multiple Access)**

- Before sending, a node **listens to the channel** to reduce collisions.
- However, due to propagation delay, collisions still cannot be completely eliminated.

**CSMA/CD (CSMA with Collision Detection)**

- Performs **collision detection** during transmission.
- Core protocol of **Ethernet**.
- When a collision is detected, the node immediately stops transmitting and waits for a **random backoff time (exponential backoff)** before retrying.

### Taking-Turns Protocols

**Polling Protocol**

- A single **master node** polls other nodes in sequence and grants them permission to send.
- Pros: No collisions, efficient use of the channel.
- Cons: If the master fails, the entire system stops; additional delay due to polling overhead.

**Token Passing**

- A special control frame called a **token** circulates among nodes.
- Only the node holding the token may transmit.
- Pros: Distributed control, efficient and orderly.
- Cons: If a node fails or the token is lost, a recovery procedure is required.

### DOCSIS: Multiple Access in Cable Internet

**DOCSIS (Data-over-Cable Service Interface Specification)**

is the physical and data link layer standard for cable Internet.

**Downstream Channel**

- Data flows from the CMTS to multiple cable modems.
- **Broadcast-based**, so there are no collisions.
- Uses FDM to separate frequency bands.

**Upstream Channel**

- Multiple cable modems send data to the CMTS.
- Based on a **TDM structure**, where time is divided into minislots and allocated for transmissions.
- If minislot requests collide, **binary exponential backoff** is used to resolve contention.

---

## 6.4 Link-Layer Switching and LANs

### Overview

- A switch operates at the **data link layer (Layer 2)** and forwards frames based on **MAC addresses**.
- It does not understand IP addresses, so it does **not** use routing algorithms (like OSPF).
- The destination is determined by a **link-layer address (MAC)**, not a **network-layer address (IP)**.

### MAC Addresses

- A MAC address is the **physical address** used at the data link layer (48 bits, 6 bytes).
- It is assigned to the NIC (Network Interface Card) and is **unique per device**.
- While an IP address can change depending on the network location, a MAC address usually stays constant as long as the device does not change.
    - Example analogy: Resident registration number = MAC address, Home address = IP address, Name = Hostname
- IEEE assigns address blocks to manufacturers (the first 24 bits identify the vendor).
- **Notation:** Six pairs of hexadecimal numbers (e.g., `00:1A:92:4B:12:AF`).

### How MAC Addresses Are Used

1. The sending adapter includes the destination MAC address in the frame and transmits it.
2. The receiving adapter checks the destination MAC address and:
    - If it matches its own MAC address, it passes the frame up to higher layers.
    - Otherwise, it discards the frame.
3. If the broadcast address `FF:FF:FF:FF:FF:FF` is used, **all nodes on the LAN** receive the frame.

### ARP (Address Resolution Protocol)

- ARP is the protocol that maps between **IP addresses and MAC addresses**.
- It operates only for communication within the **same LAN/subnet**.
- Each device maintains an **ARP table** containing IP–MAC mappings.
    - Each entry has a **TTL (Time-To-Live)**, after which it is removed.

**ARP Operation**

1. If the sender does not know the destination’s MAC address, it sends an **ARP request (broadcast)**.
2. The target host checks the request, and if the IP matches its own, it sends an **ARP reply (unicast)**.
3. The sender receives the reply and **stores the mapping** in its ARP table.
4. For subsequent transmissions to the same destination, it uses the MAC address from the ARP table to build frames.

**Characteristics**

- Works automatically without manual configuration (plug and play).
- If DNS converts “hostname → IP address,” ARP converts **“IP address → MAC address.”**

### Sending to Nodes Outside the Subnet

- If the destination is on a different subnet, the frame is sent to the **MAC address of the router’s interface** (the default gateway).
- The router inspects the IP destination address and forwards the packet to the next hop.
- Thus, at the link layer, the **router interface’s MAC address** is the actual destination of the frame.

### Ethernet

### Characteristics

- The most widely used **LAN technology** (IEEE 802.3 standard).
- Modern Ethernet typically uses a **switch-based star topology**.
- Provides **connectionless** and **unreliable** service:
    - No retransmission at the Ethernet layer if a frame is lost (TCP handles reliability).
    - No handshake is performed before sending a frame.

### Ethernet Frame Structure

| Field | Length | Description |
| --- | --- | --- |
| **Preamble** | 8B | Sender/receiver clock synchronization |
| **Destination MAC** | 6B | Address of the receiving adapter |
| **Source MAC** | 6B | Address of the sending adapter |
| **Type** | 2B | Upper-layer protocol (IPv4, IPv6, etc.) |
| **Data** | 46–1500B | Payload (e.g., IP datagram) |
| **CRC** | 4B | Error-detection code (link-layer level) |

### Link-Layer Switch

### Role of a Switch

- A switch reads incoming frames and **forwards them based on MAC addresses** (filtering and forwarding).
    - **Filtering** – Decide whether to drop the frame or forward it.
    - **Forwarding** – Decide which interface to send the frame out of, and transmit it.
- Each switch maintains a **switch table**:
    
    (MAC address ↔ interface number ↔ timestamp)
    

### Main Functions of a Switch

| Function | Description |
| --- | --- |
| **Filtering** | Decide whether to drop or forward a frame |
| **Forwarding** | Send a frame out on a specific interface |
| **Broadcast** | When MAC is unknown, send out all ports |
| **Self-Learning** | Automatically record source MAC and interface |

### Characteristics of Switches

- No collisions (each port is its own segment) → no need for a MAC (multiple access) protocol.
- Can connect heterogeneous links (different speeds/media).
- Easier to collect statistics and monitor the network.
- Plug-and-play device — no special configuration is required for basic operation.

### Spanning Tree Protocol (STP)

- In a switched LAN, if there are **loops between switches**, broadcast frames can circulate indefinitely, causing a **broadcast storm** and network outage.
- To prevent this, **IEEE 802.1D Spanning Tree Protocol (STP)** is used.
- STP analyzes the topology between switches and **automatically blocks some links** to ensure there are **no loops**, creating a logical **tree structure**.
- If a link fails, STP can reactivate a previously blocked link to **automatically restore connectivity**.

> In short, switches prevent collisions but do not inherently prevent loops.
> 
> 
> STP is a **link-layer automatic protection mechanism** designed specifically to prevent such loops.
> 

### Virtual LANs (VLANs)

**Why VLANs Are Needed**

A single physical network can be divided into multiple **logical LANs**.

- Traffic isolation (improved security)
- Better efficiency (smaller broadcast domains)
- Flexible user management (users can move physically without changing their logical network)

**Port-Based VLANs**

- Switch ports are grouped into VLANs.
- Only ports in the **same VLAN** can communicate directly.
- Traffic between different VLANs requires a **router** or **Layer 3 switch**.

**VLAN Trunking**

- A technique to carry multiple VLANs over a single physical link.
- On trunk ports, a **VLAN tag (IEEE 802.1Q)** is added.
- The VLAN tag is added by the sending switch and removed by the receiving switch.
- Tag structure:
    - **TPID (2B)**: Identifies the frame as a VLAN-tagged frame.
    - **TCI (2B)**: Contains VLAN ID (12 bits) + priority bits (3 bits).

### Switch vs Router

| Aspect | Switch | Router |
| --- | --- | --- |
| **Layer** | Layer 2 (MAC) | Layer 3 (IP) |
| **Address Type** | MAC address | IP address |
| **Plug and Play** | Yes | No |
| **Collision Handling** | No collisions | No collisions |
| **Broadcast Control** | Limited | Can isolate via routing |
| **Usage Example** | Communication within a LAN | Between VLANs or external networks |

---

## 6.5 Link Virtualization: A Network as a Link Layer

### Overview

In an extended view of the data link layer, **link virtualization** refers to technologies that make **multiple network paths appear as a single logical link**.

A representative example is **MPLS (Multiprotocol Label Switching)**.

MPLS keeps the traditional IP routing architecture, while enabling:

- **Faster packet forwarding**
- **QoS (Quality of Service) guarantees**
- **Traffic engineering (path control and optimization)**

### Concept of MPLS

- In traditional IP routing, routers examine the destination IP address and perform **longest prefix matching** to determine the next hop.
- MPLS shortens this process by attaching a **fixed-length label** to the packet and forwarding based on that label.
- Routers that support MPLS **do not need to inspect the IP header**; they simply switch packets based on the label.
- Such routers are called **LSRs (Label-Switched Routers)**.

**Key Idea**

> MPLS does not completely replace IP routing.
> 
> 
> It adds a **label-based forwarding mechanism** on top of an IP-based infrastructure.
> 

### MPLS Header Structure

MPLS inserts its header **between** the Layer 2 header (e.g., Ethernet) and the Layer 3 header (IP).

| Field | Size | Description |
| --- | --- | --- |
| **Label** | 20 bits | Logical path identifier for the packet |
| **Exp** | 3 bits | QoS priority or experimental use |
| **S (Bottom of Stack)** | 1 bit | Indicates whether this is the last label in the stack |
| **TTL** | 8 bits | Time To Live — prevents infinite loops |
- MPLS headers are used **only between MPLS-capable routers**.
- IP addresses are not modified; forwarding is done **at a link-layer-like level** using labels.

### MPLS Operation

1. The **ingress LSR (entry router)** examines the packet’s destination and **attaches an MPLS label**.
2. **Transit LSRs (intermediate routers)** ignore the IP header and forward the packet based solely on the label using their label forwarding tables.
3. The **egress LSR (exit router)** removes the label and forwards the packet as a normal IP packet.

→ This is generally faster than pure IP routing,

and the **fixed-length label lookup** can be efficiently implemented in hardware.

### Benefits of MPLS

| Feature | Description |
| --- | --- |
| **High-speed switching** | Forwarding based on labels without IP lookup |
| **Traffic Engineering** | Multiple paths can be controlled and balanced |
| **QoS Guarantees** | Priority handling using the Exp bits |
| **Virtual Private Networks (VPNs)** | Labels can separate logical links, enabling multiple VPNs over one physical network |

### MPLS vs Traditional Routing

| Aspect | Traditional IP Routing | MPLS |
| --- | --- | --- |
| **Path decision** | Based on destination IP | Based on label |
| **Table lookup** | Longest prefix match | Fixed-length label lookup |
| **Forwarding speed** | Slower (software-oriented) | Faster (hardware-friendly) |
| **Path control** | Mostly automatic (shortest path) | Policy-based / engineered paths |
| **QoS support** | Limited | Priority-based packet handling |

### Traffic Engineering (TE)

- IP routing typically chooses only the **shortest path**, which can cause congestion on certain links.
- MPLS can establish multiple **Label Switched Paths (LSPs)** to distribute load across different routes.
- Network operators can configure MPLS so that specific traffic types (e.g., VoIP, database synchronization) are routed over **preferred, high-quality paths**.

---

## 6.6 Data Center Networking

### Overview

A data center is an infrastructure where **a large number of servers (hosts)** are interconnected with a high-speed network.

It is the backbone for cloud services and web applications.

**Three main purposes:**

1. Providing content such as web, email, and streaming
2. Large-scale distributed computation (e.g., search engine indexing)
3. Providing **cloud computing infrastructure** (AWS, GCP, Azure, etc.)

### Data Center Components

**Host**

- The basic server unit in a data center (often in **blade server** form).
- Includes **CPU, memory, and disk**, usually mounted in **racks**.
- Each host typically has an internal private IP address (private network).

**TOR (Top-of-Rack) Switch**

- Located at the top of each rack and connects all hosts in that rack.
- Connects upward to aggregation/core switches, enabling external communication.
- Commonly uses **1GbE, 10GbE, or 40GbE ports**.

**Border Router**

- Connects the external Internet to the internal data center network.
- Acts as the **gateway** through which external client requests enter the data center.

**Load Balancer**

- Distributes external requests across multiple internal servers to provide **load balancing and high availability**.
- Can operate at **Layer 4 (transport layer, port-based)** or **Layer 7 (application layer, HTTP-based)**.
- Often performs address translation similar to NAT to hide the real IPs of internal servers.

**Benefits**

- Even load distribution
- Fault tolerance
- Improved security by hiding internal structure

### Hierarchical Network Architecture

| Layer | Role |
| --- | --- |
| **Access Layer** | TOR switches; directly connect hosts |
| **Aggregation Layer** | Connect multiple TOR switches upwards |
| **Core Layer** | Connects to upper networks and border routers (handles Internet traffic) |
- Hosts usually communicate within **the same subnet**.
- **VLAN segmentation** is used to limit broadcast domains.
- For resilience, **redundant links and switches** are essential.

### Bottleneck Issues

- When there is heavy traffic between racks, **upper-layer switches or links** can become bottlenecks due to **insufficient bandwidth**.
- Example: If there are too few links between TOR and core switches, cross-rack transfer speeds can drop sharply.

**Mitigation Strategies**

- Use higher-speed switches and links (more expensive).
- Place related services and data in the **same rack**.
- Use **multipath connectivity**:
    - Multiple parallel links between TOR and upper-layer switches increase **path diversity and reliability**.

### Trends in Data Center Networking

**1. Cost Reduction and Scale-Out Architecture**

- Instead of a few expensive devices, use **many inexpensive switches** in a hierarchical topology.
- Since all servers must be able to communicate with each other, instead of full mesh, use **Clos / Fat-Tree topologies**.

**2. Centralized SDN Control**

- Data centers are managed by a single organization, making **SDN (Software-Defined Networking)** easier to deploy.
- A **central controller** manages switch flow tables → enables rapid reconfiguration of network behavior.

**3. Virtualization**

- **Virtual machines (VMs)** and **containers** are decoupled from physical servers and can move between them.
- Network connectivity must be maintained even when VMs move → use **virtual network technologies** like VXLAN, NVGRE, Geneve.
- Directory-based address mapping systems are introduced to replace ARP broadcasts at scale.

**4. Physical Constraints**

- Data centers run in **ultra-low-latency, high-bandwidth environments**.
- Standard TCP congestion control is not ideal here →
    
    Enhanced protocols such as **DCTCP (Data Center TCP)** and **RDMA over Ethernet** are used.
    

**5. Modular Data Centers (MDCs)**

- Mini data centers that can be assembled and transported in **container units**.
- Easy to deploy and scale.
- Often designed as “consumable” infrastructure: used for a period and then replaced when outdated.
- Each container has its own internal network, and containers are interconnected via a core network.

**6. Continuous Build-Out and Customization**

- Large cloud providers **customize their own hardware and network stack**
    
    (e.g., Google Jupiter, AWS Nitro).
    
- They design and build switches, routers, NICs, and SDN software tailored to their needs.

**7. High Availability**

- Use of **multiple Availability Zones (AZs)**: data centers are replicated across different buildings or regions.
- In case of failure, traffic is automatically rerouted (failover) to maintain service availability.

---

## 6.7 Web Page Request Processing (Summary Flow)

### 1) Network Initialization — DHCP

1. The laptop boots and connects to the switch.
2. The laptop sends a **DHCP Discover** message as a broadcast: UDP (src 68 → dst 67), IP destination 255.255.255.255, Ethernet destination FF:FF:FF:FF:FF:FF.
3. The switch forwards this broadcast out all ports, and the router’s DHCP server receives it.
4. The DHCP server responds with **DHCP Offer/ACK**, providing an IP address, subnet mask, **default gateway**, and **DNS server**.
5. The laptop stores these settings and updates its routing table with the rule: “For external destinations, send packets to the gateway.”

### 2) Learning the Gateway’s MAC — ARP

1. To learn the MAC address of the gateway IP, the laptop sends an **ARP request** as a broadcast.
2. The router replies with an **ARP reply** containing its own MAC address, sent as a unicast.
3. The laptop stores the gateway’s IP–MAC mapping in its ARP cache.

### 3) Domain Name Resolution — DNS

1. The laptop creates a **DNS query (UDP port 53)** and sends it with the IP destination set to the DNS server’s IP, and the **Ethernet destination set to the gateway’s MAC**.
2. The packet is forwarded through the router/ISP internal routing and reaches the DNS server.
3. The DNS server replies with a response containing the mapping **www.example.com → web server IP**.
4. The laptop extracts the **web server IP address** from the response.

### 4) Establishing a Connection — TCP 3-Way Handshake

1. The laptop sends a **SYN** segment (destination port 80/443). The Ethernet destination is the gateway’s MAC, and the IP destination is the web server’s IP.
2. Routers along the path consult their **forwarding tables** to decide the next hop and forward the packet.
3. The web server responds with **SYN+ACK**, and the laptop replies with an **ACK**, completing the **TCP 3-way handshake** and establishing the connection.

### 5) Requesting and Receiving Content — HTTP

1. The browser sends an **HTTP GET** request over the TCP connection (or, for HTTPS, after a TLS session is established).
2. The web server responds with **HTTP 200 OK + content (HTML/CSS/JS/images)**, split across multiple TCP segments.
3. The laptop’s TCP layer handles **reordering, error checking, and retransmissions**, and the browser renders the received byte stream.

### 6) Follow-up Actions — Persistent Connection / Teardown

1. Additional resources from the same server are fetched over the **same TCP connection** (HTTP/1.1 Keep-Alive) or via **multiplexing in HTTP/2/3**.
2. When there is no more data to send, the connection is closed with a **FIN/ACK exchange** (and session teardown if using HTTPS).
3. The browser/OS stores the **DNS results and connection info** in caches to reduce latency for subsequent requests.

### Notes (Depending on the Situation)

- Through **switch self-learning**, the switch’s port–MAC mappings are filled in automatically.
- In a **NAT** environment, the border router translates private IP:port to a **public IP:port**.
- If there is congestion or loss, **TCP congestion control and retransmission** adjust the sending rate.
- For HTTPS, a **TLS handshake** runs right after TCP; for QUIC (HTTP/3), a **UDP-based 1-RTT handshake** is used instead.
