# 2.1-4 트랜스포트 계층 (Transport Layer)

> Active recall
> 
> - 트랜스포트 계층의 **핵심 역할**은 무엇인가?
> - 트랜스포트 계층과 **네트워크 계층의 차이점**은 무엇인가?
> - **다중화(Multiplexing)** 와 **역다중화(Demultiplexing)** 는 각각 어떤 기능을 하는가?
> - **TCP와 UDP의 근본적인 차이점**은 무엇인가?
> - **TCP 세그먼트 구조**는 어떤 필드들로 구성되는가?
> - **신뢰적 데이터 전송(Reliable Data Transfer)** 은 어떤 원리로 구현되는가?
> - **GBN(Go-Back-N)** 과 **SR(Selective Repeat)** 프로토콜의 차이는 무엇인가?
> - **TCP의 흐름 제어(Flow Control)** 와 **혼잡 제어(Congestion Control)** 는 각각 무엇을 다루는가?
> - **슬로 스타트(Slow Start)**, **혼잡 회피(Congestion Avoidance)**, **빠른 회복(Fast Recovery)** 은 각각 어떻게 동작하는가?
> - **QUIC 프로토콜**은 왜 등장했으며, 기존 **TCP와 비교해 어떤 점이 다른가?**

---

## 4.1 트랜스포트 계층 서비스 및 개요

### 트랜스포트 계층의 역할

- 서로 다른 호스트의 **프로세스 간 논리적 통신(logical communication)** 제공
- **네트워크 계층(IP)** 위에서 동작하며, IP의 “호스트 간 전달”을 “**프로세스 간 전달**”로 확장
- **종단 시스템에서만 동작**, 라우터는 처리하지 않음

### 동작 개념

- **송신 측**: 애플리케이션 데이터를 **세그먼트(segment)** 로 분할 → 헤더 추가 → IP 계층으로 전달
- **수신 측**: IP가 세그먼트를 넘겨주면 재조립 후 **해당 프로세스에 전달**
- **신뢰성, 오류 복구, 순서 보장**은 트랜스포트 계층이 담당

### 네트워크 계층과의 관계

| 구분 | 네트워크 계층(IP) | 트랜스포트 계층(TCP/UDP) |
| --- | --- | --- |
| 통신 단위 | 호스트 ↔ 호스트 | 프로세스 ↔ 프로세스 |
| 위치 | 모든 라우터 | 종단 시스템 내부 |
| 서비스 | 비신뢰적(best-effort) | TCP: 신뢰적 / UDP: 비신뢰적 |
- 트랜스포트 서비스는 IP의 한계(지연·대역폭 보장 X)에 제약받음
- TCP는 비신뢰적 IP 위에서 **오류 검출·재전송**으로 신뢰성 제공

### 주요 프로토콜

| 프로토콜 | 특징 | 사용 예시 |
| --- | --- | --- |
| **TCP** | 신뢰적, 연결지향, 혼잡/흐름 제어 | HTTP, FTP, SMTP |
| **UDP** | 비신뢰적, 비연결, 지연 최소 | 스트리밍, 게임, DNS |

### IP 서비스 모델

- **최선형 전달(best-effort)**
    
    → 전달·순서·무결성 **모두 보장하지 않음**
    
- TCP는 이 위에서 **신뢰적 데이터 전송(RDT)** 을 구현한다.

---

## 4.2 다중화와 역다중화 (Multiplexing & Demultiplexing)

### 개념

- **다중화(Multiplexing)**: 여러 애플리케이션 프로세스의 데이터를 모아 네트워크로 내보내는 과정
- **역다중화(Demultiplexing)**: 수신된 세그먼트를 **올바른 소켓(프로세스)** 으로 전달하는 과정
- 즉, **“호스트 간 전달”을 “프로세스 간 전달”로 확장하는 역할**

### 트랜스포트 계층의 기본 동작

1. **수신 시**
    - 네트워크 계층에서 세그먼트를 받음
    - 세그먼트의 **헤더 필드(포트 번호 등)** 를 확인
    - 해당 소켓(프로세스)으로 데이터 전달 (**역다중화**)
2. **송신 시**
    - 여러 소켓에서 데이터를 수집
    - 각 데이터에 **출발지/목적지 포트 번호** 등 헤더 추가
    - 세그먼트로 캡슐화 후 네트워크 계층으로 전달 (**다중화**)

### UDP의 다중화 / 역다중화

- UDP 소켓은 `(목적지 IP, 목적지 포트)`의 **2-튜플**로 식별
- 같은 목적지 포트와 IP를 가진 세그먼트는 **같은 소켓으로 전달**
- **출발지 포트 번호**는 회신 시 상대방이 응답할 주소로 사용

> 예: DNS 질의(UDP 53)는 클라이언트가 임시 포트를 열고, 서버가 목적지 포트 53으로 응답함
> 

### TCP의 다중화 / 역다중화

- TCP 소켓은 `(출발지 IP, 출발지 Port, 목적지 IP, 목적지 Port)`의 **4-튜플**로 식별
- 즉, **같은 서버 포트(예: 80)** 로 여러 클라이언트가 동시에 연결해도
    
    각 연결이 서로 다른 **4-튜플**을 가지므로 구분 가능
    

> 예: 웹 서버는 포트 80 하나만 열어두지만,
> 
> 
> 각 클라이언트 연결에 대해 다른 출발지 IP·포트 조합을 사용 → 동시에 여러 세션 유지 가능
> 

### 연결 과정 예시 (TCP)

1. 클라이언트가 TCP 소켓 생성 → 연결 요청 전송(SYN)
2. 서버는 “환영 소켓(Well-known port)”에서 요청을 수락
3. 연결이 수립되면 새로운 **연결 소켓** 생성
    - 식별자: (클라이언트 IP, 클라이언트 Port, 서버 IP, 서버 Port)
4. 이후 데이터는 해당 소켓으로 전달 (역다중화)

### 웹 서버에서의 다중 연결

- 여러 클라이언트가 **같은 서버 포트(80)** 로 접속해도
    
    출발지 IP·포트 조합이 다르므로 각 연결은 별개의 세션으로 관리됨
    
- 고성능 서버는 각 연결마다 **스레드(Thread)** 또는 **비동기 이벤트 루프**로 처리

---

## 4.3 비연결형 트랜스포트: UDP (User Datagram Protocol)

### 개념

- **UDP**는 트랜스포트 계층이 제공할 수 있는 **가장 단순한 형태의 서비스**
- IP 위에 최소한의 기능만 추가
    
    → **다중화/역다중화**, **간단한 오류 검사**
    
- **비연결형(Connectionless)**: 송신 전 **핸드셰이크 없음**, 상태 유지 X

### 동작 방식

1. 애플리케이션 프로세스에서 메시지 수신
2. 세그먼트 생성 (출발지/목적지 포트 번호 추가)
3. IP 계층으로 전달 → 데이터그램에 캡슐화되어 전송
4. 수신 측은 목적지 포트 번호를 기준으로 적절한 **소켓으로 전달**

> UDP는 “전송 즉시 보냄” 모델이다.
> 
> 
> 연결 설정이나 혼잡 제어가 없으므로 지연이 거의 없다.
> 

### UDP의 장점

- **빠른 전송**: 연결 설정(3-way handshake) 없음
- **지연 최소**: 전송 즉시 IP로 전달
- **헤더 오버헤드 적음**: 8바이트 (TCP는 20바이트)
- **상태 없음**: 서버는 더 많은 클라이언트를 동시에 처리 가능
- **애플리케이션이 제어권 가짐**: 필요 시 자체 재전송·혼잡 제어 구현 가능

> 예시: DNS, 스트리밍, 게임, 화상회의(VoIP), QUIC
> 

### UDP의 단점

- **혼잡 제어 없음** → 네트워크 폭주 위험
- **신뢰성 없음** → 손실·순서 보장 X
- **오류 복구 없음** → 체크섬으로 검출만 하고 복구하지 않음

> UDP 송신자가 많을 경우 TCP 트래픽이 밀려 공평성(fairness) 이 깨질 수 있음
> 

### UDP 세그먼트 구조

| Source Port # | Destination Port # |
| --- | --- |
| **Length** | **Checksum** |
| **Application Data (Message)** |  |

> 전체 UDP 헤더 크기: 8바이트(고정)
> 
> 
> TCP보다 훨씬 단순하며, 최소한의 제어 정보만 포함한다.
> 

### UDP 체크섬 (Checksum)

- 송신자가 모든 16비트 단위 데이터를 더해 1의 보수를 취함
- 수신자는 같은 방식으로 합산하여
    - 결과가 `1111111111111111` → 정상
    - `0` 포함 → 오류 발생
- 오류 감지는 하지만 **재전송(복구)은 하지 않음**

### UDP의 신뢰성 확장

- UDP 자체는 비신뢰적이지만, **상위 애플리케이션에서 신뢰성 구현 가능**
    
    → 예: Google **QUIC**
    
    - UDP 위에서 작동
    - 자체 **재전송, 혼잡 제어, 암호화**를 구현
    - HTTP/3의 기반 프로토콜

---

## 4.4 신뢰적인 데이터 전송의 원리 (Principles of Reliable Data Transfer)

### 개념

- **신뢰적인 데이터 전송(Reliable Data Transfer, RDT)** 은
    
    **데이터가 손상·손실되지 않고, 순서대로 전달되도록 보장하는 메커니즘**이다.
    
- 실제 네트워크(IP)는 비신뢰적이므로, 트랜스포트 계층(TCP)은 RDT를 직접 구현해야 한다.
- 이 개념은 링크 계층·응용 계층에서도 동일하게 적용된다.

### 기본 목표

- **데이터 무결성(Data Integrity)**: 비트 오류 없이 정확한 데이터 전달
- **데이터 손실 복구(Loss Recovery)**: 손실 시 재전송
- **순서 보장(In-order Delivery)**: 전송된 순서대로 수신

### 핵심 구성 요소

| 구성요소 | 역할 |
| --- | --- |
| **체크섬(Checksum)** | 비트 오류 검출 |
| **순서 번호(Sequence Number)** | 중복 및 순서 제어 |
| **확인응답(ACK)** | 정상 수신 알림 |
| **부정응답(NAK)** | 오류 발생 알림 |
| **타이머(Timer)** | 손실 감지 후 재전송 |
| **윈도(Window)** | 파이프라인 제어(GBN, SR) |

### rdt1.0 — 완전 신뢰 채널

- 하위 채널이 완전히 신뢰적 → **오류·손실 없음**
- 송신자는 `rdt_send(data)` → 패킷 생성·전송
- 수신자는 `rdt_rcv(packet)` → 상위 계층으로 전달
- **피드백 불필요**, 단일 상태 FSM

### rdt2.0 — 비트 오류 존재

- 채널에서 **비트 손상 발생 가능**
- **ARQ(Automatic Repeat reQuest)** 프로토콜 개념 도입
    - 오류 검출(Checksum)
    - 피드백(ACK/NAK)
    - 재전송(Retransmit)
- **Stop-and-Wait 방식**: 하나 전송 → 응답 대기 → 다음 전송

> 문제점: ACK/NAK가 손상되면 송신자는 상태를 알 수 없음 → 중복 전송 위험
> 

### rdt2.1 / rdt2.2 — ACK/NAK 손상 해결

- 패킷에 **순서 번호(Sequence Number)** 추가
- 수신자가 중복 패킷을 구분 가능
- **rdt2.1**: ACK/NAK 모두 사용
- **rdt2.2**: **NAK 제거**, 중복 ACK로 대체
    
    → 같은 ACK 두 번 수신 시, 이전 패킷 재전송
    

### rdt3.0 — 손실 발생 채널

- 패킷 또는 ACK 손실 가능
- 송신자는 **타이머(Timer)** 사용
    - 일정 시간 내 ACK 없으면 재전송
    - “**Stop-and-Wait + Timeout**” 구조
- 순서 번호로 **중복 패킷 구분**
- → **Alternating Bit Protocol (ABP)**

### 파이프라이닝된 RDT

- Stop-and-Wait는 효율 낮음 → **파이프라이닝(Pipelining)** 도입
- 여러 패킷을 한 번에 전송하여 채널 이용률 향상
- 확인응답 도착 전에도 전송 가능

| 문제 | 해결 방식 |
| --- | --- |
| 순서 관리 | **순서 번호 범위 확장** |
| 손실 복구 | **재전송 정책 필요** |
| 버퍼링 | 송신자·수신자 모두 버퍼 필요 |

### GBN (Go-Back-N)

- 누적 ACK 기반 파이프라인 프로토콜
- 윈도 크기 N → **최대 N개의 미확인 패킷 전송 가능**
- 손실 시 **base 이후 모든 패킷 재전송**
- 수신자는 **순서가 어긋난 패킷은 버림**
- 단순하지만 **재전송 오버헤드 큼**

### SR (Selective Repeat)

- **선택적 재전송**: 손상된 패킷만 재전송
- 각 패킷에 **개별 ACK/타이머**
- 수신자는 순서가 어긋난 패킷도 **버퍼링 후 순서 복원**
- 효율적이지만 구현 복잡

| 항목 | GBN | SR |
| --- | --- | --- |
| 재전송 단위 | 손실 이후 전부 | 손실된 것만 |
| 수신자 버퍼링 | X | O |
| 구현 복잡도 | 낮음 | 높음 |
| 효율성 | 낮음 (중복 전송 많음) | 높음 (불필요 전송 적음) |

---

## 4.5 연결지향형 트랜스포트: TCP (Transmission Control Protocol)

### TCP의 특징

- **연결지향형 (Connection-Oriented)**: 송신자와 수신자가 **3-way handshake**로 연결을 설정하고, **4-way handshake**로 종료함
- **신뢰적 전송 (Reliable Transfer)**: 손실·중복·순서 오류를 복구하여 **정확한 데이터 전달**을 보장함
- **전이중 통신 (Full-Duplex)**: 양쪽이 동시에 송수신 가능하며, **독립적인 데이터 스트림 2개**를 유지함
- **점대점 통신 (Point-to-Point)**: 한 연결은 **1:1 통신만 지원**하며 멀티캐스트나 브로드캐스트는 불가능함
- **흐름 제어 (Flow Control)**: 수신자의 **버퍼 오버플로를 방지**하기 위해 수신 윈도(rwnd)를 이용해 송신 속도를 조절함
- **혼잡 제어 (Congestion Control)**: 네트워크 혼잡 시 **전송 속도를 줄이고**, 회복 시 **점진적으로 증가**시켜 안정성을 유지함
- **바이트 스트림 서비스 (Byte Stream Service)**: 데이터를 **경계 없는 연속적인 바이트 흐름**으로 처리하며, 메시지 단위를 구분하지 않음
- **순서 제어 (In-order Delivery)**: 수신 측이 **순서가 어긋난 세그먼트도 버퍼링 후 재조립**하여 애플리케이션에 **전송 순서 그대로 전달함**

### TCP 연결 및 동작

1. **연결 수립 (3-way handshake)**
    - SYN → SYN+ACK → ACK 순으로 3단계 교환
        - SYN = “연결을 시작(Synchronize Sequence Numbers)”하겠다는 신호
    - 초기 순서 번호(ISN)를 상호 교환 후 연결 확립
    
    | 단계 | 송신자 동작 | 수신자 동작 | 설명 |
    | --- | --- | --- | --- |
    | ① | `SYN` 전송 (SYN=1, Seq=x) |  | 연결 요청 시작 |
    | ② |  | `SYN+ACK` 응답 (SYN=1, ACK=x+1, Seq=y) | 연결 승인 |
    | ③ | `ACK` 전송 (ACK=y+1, SYN=0) |  | 연결 확립 완료 |
2. **데이터 전송**
    - 데이터는 스트림(Stream) 형태로 TCP에 전달
    - TCP는 데이터를 **세그먼트(segment)** 단위로 쪼개어 IP로 전달
    - 수신 측은 세그먼트를 버퍼에 저장 후 애플리케이션으로 전달
    
    > 각 소켓 당 수신 버퍼와 송신 버퍼가 생성됨
    > 
3. **연결 해제**
    
    
    | 단계 | 송신자(Client) | 수신자(Server) | 설명 |
    | --- | --- | --- | --- |
    | ① | **FIN=1** |  | 클라이언트 → “더 이상 보낼 데이터 없음” |
    | ② |  | **ACK=1** | 서버 → “그만 보낸다는 거 알겠음” |
    | ③ |  | **FIN=1** | 서버 → “나도 이제 보낼 데이터 없음” |
    | ④ | **ACK=1** |  | 클라이언트 → “확인, 연결 완전히 종료” |

### TCP 세그먼트 구조

| **필드(Field)** | **크기(Byte)** | **의미(간단 설명)** |
| --- | --- | --- |
| **Source Port #** | 2 | 송신 프로세스 식별 |
| **Destination Port #** | 2 | 수신 프로세스 식별 |
| **Sequence Number** | 4 | 세그먼트의 첫 번째 데이터 바이트 번호 |
| **Acknowledgment Number** | 4 | 다음에 수신자가 기대하는 바이트 번호 |
| **Header Length** | 4bit | 헤더의 길이 지정 |
| **Flags (6bit)** | - | 제어 비트 (SYN, ACK, FIN, RST, PSH, URG) |
| **Receive Window** | 2 | 수신 가능한 버퍼 크기(흐름 제어용) |
| **Checksum** | 2 | 오류 검출 |
| **Urgent Pointer** | 2 | 긴급 데이터의 끝 위치 |
| **Options** | 가변 | MSS, 윈도 확장 등 설정 정보 |
| **Data** | 가변 | 실제 애플리케이션 데이터 |
- `출발지 포트 번호(source port number)`
- `도착지 포트 번호(destination port number)`
- `체크섬 필드(checksum field)` - 오류 검출
- 32비트 `순서 번호 필드(sequence number field)`
- 32비트 `확인응답 번호 필드(acknowledgement number field)`
- 16비트 `수신 윈도(receive window)` - 흐름 제어에 사용
- 4비트 `헤더 길이 필드(header length field)`
- `옵션 필드(option field)`
    - 선택적이고 가변적인 길이
    - 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용
- `플래그 필드(flag field)` - 6비트
    - `ACK` 비트 : 확인응답 필드에 있는 값이 유용함을 가리키는 데 사용된다
    - `RST`, `SYN`, `FIN` 비트 : 연결 설정과 해제에 사용된다
    - `PSH` 비트 : 이 비트가 설정되었다면 이것은 수신자가 데이터를 상위 계층에 즉시 전달해야 함을 가리킨다
    - `URG` 비트
        - 이 세그먼트에서 송신 측 상위 계층 개체가 ‘긴급’으로 표시하는 데이터임을 가리킨다
        - 이 긴급 데이터의 마지막 바이트의 위치는 16비트의 `긴급 데이터 포인터 필드(urgent data pointer field)`에 의해 가리켜진다

### 순서 번호와 확인응답 번호

> TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 본다
> 
- **Sequence Number**: 세그먼트 내 첫 번째 바이트의 번호
- **Acknowledgment Number**: 다음으로 기대하는 바이트 번호
- **누적 ACK(Cumulative ACK)**: 잃어버린 바이트 이전까지만 확인
- 순서가 어긋난 세그먼트는 **버퍼링 후 재정렬** (실제 TCP 구현의 일반 방식)

### RTT 예측 및 타임아웃

- **RTT(Round Trip Time)** 은 세그먼트를 보낸 뒤 ACK을 받기까지 걸린 왕복 시간을 의미
- TCP는 매번 측정한 RTT 값을 기반으로 **평균 RTT를 예측**
- RTT의 변동성을 고려해 단순 평균이 아닌 **편차(Deviation)** 도 함께 계산
- 최종적으로 계산된 **타임아웃 시간(Timeout Interval)** 은 평균 RTT보다 약간 길게 설정해
    
    **불필요한 재전송을 줄이면서 손실을 빠르게 감지하도록 동작**
    

### TCP 신뢰적 데이터 전송 메커니즘

> TCP는 *IP의 비신뢰적인 최선형 서비스에서* `신뢰적인 데이터 전송 서비스(reliable data transfer service)`를 제공
> 
- 프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 **손상되지 않음**을 보장
- **중복이 없다**는 것과 **순서가 유지된다**는 것을 보장

1. **데이터 수신**: 애플리케이션 → 세그먼트 생성 → IP로 전송
2. **타임아웃 발생**: 해당 세그먼트 재전송
3. **ACK 수신**: 누적 ACK 기반으로 송신 버퍼 정리 및 타이머 갱신
    - `SendBase` : **수신 확인응답이 확인되지 않은** / **가장 오래된** 바이트의 순서번호
    - `SendBase-1` : 수신자에게서 정확하게 차례대로 수신되었음을 알리는 마지막 바이트의 순서번호

> TCP는 기본적으로 GBN 구조를 따르지만,
> 
> 
> 순서가 어긋난 세그먼트를 **버퍼링**하고,
> 
> 선택적 확인응답(SACK) 기능을 사용하면 **SR과 매우 유사하게 동작**
> 

### 빠른 재전송 (Fast Retransmit)

- 동일한 데이터에 대해 **3개의 중복 ACK** 수신 시,
    
    타이머 만료를 기다리지 않고 즉시 재전송
    
- 손실 감지를 빠르게 수행해 전송 지연을 최소화

### 흐름 제어 (Flow Control)

- 수신자 버퍼 오버플로 방지
- 수신자는 `rwnd(receive window)`를 통해 여유 버퍼 크기 전달
- 송신자는 `미확인 데이터량 ≤ rwnd` 유지
- **rwnd=0**일 경우, 송신자는 주기적으로 1바이트 세그먼트를 전송해 상태 확인

### SYN 플러드 공격과 방어

- **공격 원리**: SYN 세그먼트만 전송 후 ACK 미응답 → 서버 리소스 고갈
- **SYN 쿠키(SYN Cookie)**: 서버가 연결 상태를 저장하지 않고
    
    해시 기반 초기 시퀀스 번호(ISN)로 요청 검증 → 자원 낭비 방지
    

---

## 4.6 **TCP 혼잡 제어(TCP Congestion Control)**

### 개념

- **혼잡(Congestion)** 은 네트워크에 **너무 많은 송신자들이 너무 빠르게 데이터를 보내는 상황**을 의미함
- 라우터의 버퍼가 가득 차거나 링크 용량을 초과하면 **지연 증가, 패킷 손실, 재전송 증가**로 이어짐
- 혼잡 제어의 목적은 **송신 속도를 조절해 네트워크의 안정성과 효율을 유지하는 것**

### 혼잡의 원인과 비용

### 시나리오 1: 2개의 송신자, 무한 버퍼 라우터

- 두 송신자가 동일한 링크(R bps)를 공유함
- 각 송신자가 전송률을 높이면 → 각자의 처리율은 R/2를 넘지 못함
- 전송률이 R/2에 가까워질수록 **지연이 급격히 증가**, R/2 초과 시 **무한 지연 발생**

> 버퍼는 무한해도, 혼잡 시 처리율은 증가하지 않고 지연만 커짐
> 

### 시나리오 2: 유한 버퍼 라우터

- 버퍼가 한정되어 있어 **패킷 손실 발생**
- 송신자는 손실된 패킷을 **재전송**하므로 실제 네트워크 부하는 증가함

| 상황 | 결과 |
| --- | --- |
| 패킷 손실 없음 | 처리율 = 전송률 λin |
| 손실 후 재전송 발생 | 처리율 ↓ (대역폭 일부가 재전송에 사용) |
| 과도한 타임아웃 | 손실이 없더라도 지연된 패킷 재전송 → **불필요한 대역폭 낭비** |

> 즉, 재전송이 많을수록 혼잡이 심화되고 네트워크 효율이 감소함
> 

### 시나리오 3: 여러 송신자, 멀티홉 경로

- 다수의 송신자 트래픽이 라우터에서 경쟁
- 특정 구간의 라우터(병목 링크)에 부하 집중 → **일부 연결의 처리율 0에 수렴**
- 손실된 패킷은 낭비된 링크 대역폭을 유발함

> “혼잡은 단순히 한 노드의 문제를 넘어 전체 경로 자원의 낭비로 이어짐”
> 

### 혼잡 제어의 접근 방식

| 구분 | 설명 | 예시 |
| --- | --- | --- |
| **종단 간 혼잡 제어 (End-to-End)** | 네트워크가 직접 정보를 주지 않음 → 송신자가 **손실과 지연을 관찰해 혼잡을 추정** | TCP |
| **네트워크 지원 혼잡 제어 (Network-Assisted)** | 라우터가 혼잡 상태를 감지해 **송신자에게 직접 피드백 제공** | ATM ABR, ECN |

### 종단 간 혼잡 제어 (TCP 방식)

- TCP는 **패킷 손실**과 **RTT 증가**를 혼잡의 신호로 판단함
- 혼잡 감지 시 → **송신 윈도(cwnd)** 크기를 줄여 송신 속도 감소
- 네트워크 상태가 개선되면 윈도를 다시 늘려 전송률 회복

> TCP는 “손실 기반 + 지연 기반 혼합형 제어” 방식으로 동작함
> 

### 네트워크 지원 혼잡 제어

- 라우터가 혼잡 정보를 직접 송신자에게 전달
- 두 가지 방법이 있음

| 방법 | 설명 |
| --- | --- |
| **직접 피드백 (Explicit Feedback)** | 라우터가 송신자에게 **초크 패킷(choke packet)** 등을 직접 전송 |
| **간접 피드백 (Implicit Feedback)** | 라우터가 패킷 헤더 필드를 수정해 수신자가 감지 → 송신자에게 전달 (왕복 지연 필요) |

> 최근 TCP/IP에서는 ECN (Explicit Congestion Notification) 을 통해 선택적으로 라우터 피드백을 지원함
> 

---

## 4.7 혼잡 제어의 원리 (Principles of Congestion Control)

### 혼잡의 개념

- **혼잡(Congestion)** 은 네트워크에 **너무 많은 송신자가 너무 빠른 속도로 데이터를 보낼 때** 발생
- 결과적으로 **라우터 버퍼 오버플로 → 패킷 손실 → 재전송 증가 → 지연 폭증**으로 이어짐
- TCP는 혼잡을 감지하고 전송 속도를 조절하기 위해 **혼잡 제어(Congestion Control)** 메커니즘을 사용함

### TCP 혼잡 제어 변수

- **cwnd (Congestion Window)**: 송신자가 전송 가능한 데이터의 양을 제어하는 변수
- **rwnd (Receive Window)**: 수신 버퍼의 여유 공간
- 실제 전송 가능한 데이터량:
    
    `LastByteSent - LastByteAcked ≤ min(cwnd, rwnd)`
    
    → 송신 속도는 cwnd 값에 의해 제한됨
    

### 혼잡 감지 방법

1. **손실 이벤트 (Loss Event)**
    - 타임아웃 발생 또는 **중복 ACK 3회 수신**
    - → 네트워크의 혼잡으로 판단
2. **자체 클로킹(Self-clocking)**
    - ACK 도착 속도를 전송 속도 조정의 기준으로 사용
    - ACK이 늦게 오면 혼잡, 빠르게 오면 여유 있다고 판단

### TCP 혼잡 제어 알고리즘 구성 요소

1. **슬로 스타트 (Slow Start)**
2. **혼잡 회피 (Congestion Avoidance)**
3. **빠른 회복 (Fast Recovery)** *(권고사항, 필수는 아님)*

### 1) 슬로 스타트 (Slow Start)

- TCP 연결 시작 시 **cwnd = 1 MSS** 로 초기화
- ACK을 받을 때마다 **cwnd를 1 MSS씩 증가 → 지수적 증가**
- 초기 전송률을 빠르게 높여 **가용 대역폭을 탐색**

**종료 조건**

- 손실 이벤트 발생 시 → `cwnd = 1`, **새 슬로 스타트 시작**
- `cwnd ≥ ssthresh` 도달 시 → **혼잡 회피로 전환**
- 중복 ACK 3회 발생 시 → **빠른 회복(Fast Recovery)** 진입

### 2) 혼잡 회피 (Congestion Avoidance)

- `cwnd`가 `ssthresh` 이상일 때 진입
- **혼잡을 예방하기 위해 신중하게 증가**
- RTT마다 cwnd를 **1 MSS씩 선형적으로 증가 (Additive Increase)**

**종료 조건**

- **타임아웃** 발생 시 → `cwnd = 1`, `ssthresh = cwnd / 2`, 슬로 스타트로 복귀
- **중복 ACK 3회** → 빠른 회복으로 전환

### 3) 빠른 회복 (Fast Recovery)

- 3개의 중복 ACK 수신 시 진입
- 손실 세그먼트 재전송 후, **cwnd를 절반으로 줄이고** `ssthresh` 설정
- 이후 도착하는 중복 ACK마다 **cwnd를 1 MSS씩 증가**
- 손실된 세그먼트에 대한 ACK 도착 시 → **혼잡 회피로 복귀**

### AIMD (Additive Increase, Multiplicative Decrease)

- TCP 혼잡 제어의 기본 원리
- **가법적 증가(AI)**: RTT마다 cwnd를 1 MSS씩 증가
- **승법적 감소(MD)**: 혼잡 발생 시 cwnd를 절반으로 감소
- → “**조심스럽게 늘리고, 손실 시 급격히 줄인다**”는 접근 방식

### 혼잡 제어 방식 비교

| 구분 | 슬로 스타트 | 혼잡 회피 | 빠른 회복 |
| --- | --- | --- | --- |
| **증가 속도** | 지수적 증가 | 선형 증가 | 빠른 회복 후 선형 증가 |
| **감소 조건** | 손실 이벤트 | 손실 이벤트 | 중복 ACK 3회 |
| **cwnd 감소 방식** | 1 MSS로 초기화 | 절반 감소 | 절반 감소 |
| **전송률 변화** | 급격히 증가 | 점진적 증가 | 손실 후 빠른 회복 |

### TCP CUBIC (현대적 혼잡 제어)

- **리노(Reno)** 의 개선 버전 (리눅스 기본)
- 손실 발생 직전의 윈도 크기 `Wmax` 기준으로,
    
    **세제곱 함수(Cubic Function)** 로 cwnd를 조절
    
- 손실 후 빠르게 `Wmax`에 근접한 뒤, 그 주변에서 **신중하게 대역폭 탐색**
- 고대역폭·고지연 환경에서 더 효율적

### 명시적 혼잡 알림 (ECN, Explicit Congestion Notification)

- **라우터가 혼잡을 탐지하면 패킷을 버리지 않고 헤더의 ECN 비트를 설정**
- 수신자는 ACK에 **ECE(Explicit Congestion Echo)** 비트를 설정해 송신자에게 전달
- 송신자는 혼잡 윈도를 절반으로 줄이고, **CWR(Congestion Window Reduced)** 비트를 통해 대응 사실을 회신
- → 손실 없이 혼잡 신호 전달 가능

### 지연 기반 혼잡 제어 (TCP Vegas)

- 혼잡을 **손실이 아니라 RTT 증가(지연)** 으로 감지
- RTT가 최소값(RTTmin)보다 커지면 → 네트워크에 큐가 쌓였다고 판단
- **혼잡 전에 송신 속도를 줄임**으로써 지연을 줄이고 안정성 향상

### 공평성 (Fairness)

- 여러 TCP 연결이 동일한 병목 링크를 공유할 때,
    
    각 연결이 링크 대역폭을 **공평하게 나누는 특성**
    
- AIMD 원리에 의해 각 연결의 **평균 전송률 ≈ R/K (링크 대역폭 R, 연결 수 K)**
- 단, RTT가 짧은 연결이 더 빠르게 윈도 증가 → 더 많은 대역폭 점유 가능

> UDP는 혼잡 제어가 없어 TCP보다 비공평하게 대역폭을 차지할 수 있음
> 

---

## 4.8 트랜스포트 계층 기능의 발전

### 개요

- 기존 TCP의 신뢰성·혼잡 제어 성능을 유지하면서, **연결 설정 속도**와 **스트림 처리 효율**을 개선하기 위한 다양한 프로토콜이 등장함
- 대표적인 발전 사례: **QUIC (Quick UDP Internet Connections)**

### QUIC (Quick UDP Internet Connections)

- **UDP 기반**으로 동작하지만, **TCP 수준의 신뢰성과 혼잡 제어 기능**을 제공함
- **구글(Google)** 이 설계, 현재 **HTTP/3의 핵심 트랜스포트 계층 프로토콜**로 채택됨
- 인터넷 트래픽의 **7% 이상이 이미 QUIC 기반으로 전송**됨

### QUIC의 주요 특징

### 연결지향적이고 안전함

- QUIC은 UDP 위에서 **연결지향 프로토콜처럼 동작**
- TCP의 3-way handshake + TLS 보안 핸드셰이크를 **단일 과정으로 통합**
    
    → **연결 설정 속도를 크게 단축** (RTT 절감)
    
- 연결은 **연결 ID**(Connection ID)를 통해 관리되어, IP가 바뀌어도 연결 유지 가능

### 스트림 다중화 (Stream Multiplexing)

- 하나의 QUIC 연결 위에서 **여러 독립적인 스트림(Stream)** 을 전송 가능
- 각 스트림은 **별도의 신뢰적 데이터 전송**을 지원
- 하나의 스트림이 손실되어도 다른 스트림은 **지연 없이 계속 전송 가능**
    
    → TCP의 **HOL(Head-Of-Line) 차단 문제** 해결
    

### 신뢰적 데이터 전송 & 혼잡 제어

- TCP처럼 **확인응답(ACK)** 기반 신뢰적 데이터 전송 제공
- 혼잡 제어 알고리즘은 **TCP NewReno**를 기반으로 개선
- 스트림별 독립적인 오류 복구 수행

### HTTP 버전별 비교

| 구분 | **HTTP/1.1** | **HTTP/3 (QUIC 기반)** |
| --- | --- | --- |
| **트랜스포트 계층** | TCP | UDP + QUIC |
| **보안 계층** | TLS(별도 계층) | QUIC 내부 통합 |
| **스트림 구조** | 단일 스트림 | 다중 스트림 |
| **손실 영향** | 전체 전송 지연 (HOL 차단) | 해당 스트림만 영향 |
| **연결 설정 속도** | 2 RTT 이상 | 1 RTT 이하 |

### QUIC의 장점 요약

- **연결 설정 속도 빠름** (TCP+TLS보다 RTT 절감)
- **스트림 단위 병렬 전송** 지원
- **보안 계층 내장 (TLS 1.3 통합)**
- **손실 격리**로 지연 최소화
- **TCP 대비 구현 유연성** (애플리케이션 계층에서 직접 수정 가능)
