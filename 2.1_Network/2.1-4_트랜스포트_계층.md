# 2.1-4 트랜스포트 계층 (Transport Layer)

> Active recall
> 
> - 트랜스포트 계층의 역할은?
> - 트랜스포트 계층과 네트워크 계층의 차이는?
> - 다중화/역다중화란?
> - TCP와 UDP의 핵심 차이는?
> - TCP 세그먼트에는 어떤 필드들이 있는가?
> - 신뢰적 데이터 전송은 어떻게 구현되는가?
> - GBN과 SR의 차이는?
> - TCP의 흐름 제어와 혼잡 제어의 차이는?
> - 슬로 스타트, 혼잡 회피, 빠른 회복의 동작은?
> - QUIC은 왜 등장했고 TCP와 어떤 점이 다른가?

---

## 4.1 트랜스포트 계층 서비스 및 개요

### 트랜스포트 계층의 역할

- 서로 다른 호스트의 **프로세스 간 논리적 통신(logical communication)** 제공
- **네트워크 계층(IP)** 위에서 동작하며, IP의 “호스트 간 전달”을 “**프로세스 간 전달**”로 확장
- **종단 시스템에서만 동작**, 라우터는 처리하지 않음

### 동작 개념

- **송신 측**: 애플리케이션 데이터를 **세그먼트(segment)** 로 분할 → 헤더 추가 → IP 계층으로 전달
- **수신 측**: IP가 세그먼트를 넘겨주면 재조립 후 **해당 프로세스에 전달**
- **신뢰성, 오류 복구, 순서 보장**은 트랜스포트 계층이 담당

### 네트워크 계층과의 관계

| 구분 | 네트워크 계층(IP) | 트랜스포트 계층(TCP/UDP) |
| --- | --- | --- |
| 통신 단위 | 호스트 ↔ 호스트 | 프로세스 ↔ 프로세스 |
| 위치 | 모든 라우터 | 종단 시스템 내부 |
| 서비스 | 비신뢰적(best-effort) | TCP: 신뢰적 / UDP: 비신뢰적 |
- 트랜스포트 서비스는 IP의 한계(지연·대역폭 보장 X)에 제약받음
- TCP는 비신뢰적 IP 위에서 **오류 검출·재전송**으로 신뢰성 제공

### 주요 프로토콜

| 프로토콜 | 특징 | 사용 예시 |
| --- | --- | --- |
| **TCP** | 신뢰적, 연결지향, 혼잡/흐름 제어 | HTTP, FTP, SMTP |
| **UDP** | 비신뢰적, 비연결, 지연 최소 | 스트리밍, 게임, DNS |

### IP 서비스 모델

- **최선형 전달(best-effort)**
    
    → 전달·순서·무결성 **모두 보장하지 않음**
    
- TCP는 이 위에서 **신뢰적 데이터 전송(RDT)** 을 구현한다.

---

## 4.2 다중화와 역다중화 (Multiplexing & Demultiplexing)

### 개념

- **다중화(Multiplexing)**: 여러 애플리케이션 프로세스의 데이터를 모아 네트워크로 내보내는 과정
- **역다중화(Demultiplexing)**: 수신된 세그먼트를 **올바른 소켓(프로세스)** 으로 전달하는 과정
- 즉, **“호스트 간 전달”을 “프로세스 간 전달”로 확장하는 역할**

### 트랜스포트 계층의 기본 동작

1. **수신 시**
    - 네트워크 계층에서 세그먼트를 받음
    - 세그먼트의 **헤더 필드(포트 번호 등)** 를 확인
    - 해당 소켓(프로세스)으로 데이터 전달 (**역다중화**)
2. **송신 시**
    - 여러 소켓에서 데이터를 수집
    - 각 데이터에 **출발지/목적지 포트 번호** 등 헤더 추가
    - 세그먼트로 캡슐화 후 네트워크 계층으로 전달 (**다중화**)

### UDP의 다중화 / 역다중화

- UDP 소켓은 `(목적지 IP, 목적지 포트)`의 **2-튜플**로 식별
- 같은 목적지 포트와 IP를 가진 세그먼트는 **같은 소켓으로 전달**
- **출발지 포트 번호**는 회신 시 상대방이 응답할 주소로 사용

> 예: DNS 질의(UDP 53)는 클라이언트가 임시 포트를 열고, 서버가 목적지 포트 53으로 응답함
> 

### TCP의 다중화 / 역다중화

- TCP 소켓은 `(출발지 IP, 출발지 Port, 목적지 IP, 목적지 Port)`의 **4-튜플**로 식별
- 즉, **같은 서버 포트(예: 80)** 로 여러 클라이언트가 동시에 연결해도
    
    각 연결이 서로 다른 **4-튜플**을 가지므로 구분 가능
    

> 예: 웹 서버는 포트 80 하나만 열어두지만,
> 
> 
> 각 클라이언트 연결에 대해 다른 출발지 IP·포트 조합을 사용 → 동시에 여러 세션 유지 가능
> 

### 연결 과정 예시 (TCP)

1. 클라이언트가 TCP 소켓 생성 → 연결 요청 전송(SYN)
2. 서버는 “환영 소켓(Well-known port)”에서 요청을 수락
3. 연결이 수립되면 새로운 **연결 소켓** 생성
    - 식별자: (클라이언트 IP, 클라이언트 Port, 서버 IP, 서버 Port)
4. 이후 데이터는 해당 소켓으로 전달 (역다중화)

### 웹 서버에서의 다중 연결

- 여러 클라이언트가 **같은 서버 포트(80)** 로 접속해도
    
    출발지 IP·포트 조합이 다르므로 각 연결은 별개의 세션으로 관리됨
    
- 고성능 서버는 각 연결마다 **스레드(Thread)** 또는 **비동기 이벤트 루프**로 처리

---

## 4.3 비연결형 트랜스포트: UDP (User Datagram Protocol)

### 개념

- **UDP**는 트랜스포트 계층이 제공할 수 있는 **가장 단순한 형태의 서비스**
- IP 위에 최소한의 기능만 추가
    
    → **다중화/역다중화**, **간단한 오류 검사**
    
- **비연결형(Connectionless)**: 송신 전 **핸드셰이크 없음**, 상태 유지 X

### 동작 방식

1. 애플리케이션 프로세스에서 메시지 수신
2. 세그먼트 생성 (출발지/목적지 포트 번호 추가)
3. IP 계층으로 전달 → 데이터그램에 캡슐화되어 전송
4. 수신 측은 목적지 포트 번호를 기준으로 적절한 **소켓으로 전달**

> UDP는 “전송 즉시 보냄” 모델이다.
> 
> 
> 연결 설정이나 혼잡 제어가 없으므로 지연이 거의 없다.
> 

### UDP의 장점

- **빠른 전송**: 연결 설정(3-way handshake) 없음
- **지연 최소**: 전송 즉시 IP로 전달
- **헤더 오버헤드 적음**: 8바이트 (TCP는 20바이트)
- **상태 없음**: 서버는 더 많은 클라이언트를 동시에 처리 가능
- **애플리케이션이 제어권 가짐**: 필요 시 자체 재전송·혼잡 제어 구현 가능

> 예시: DNS, 스트리밍, 게임, 화상회의(VoIP), QUIC
> 

### UDP의 단점

- **혼잡 제어 없음** → 네트워크 폭주 위험
- **신뢰성 없음** → 손실·순서 보장 X
- **오류 복구 없음** → 체크섬으로 검출만 하고 복구하지 않음

> UDP 송신자가 많을 경우 TCP 트래픽이 밀려 공평성(fairness) 이 깨질 수 있음
> 

### UDP 세그먼트 구조

| Source Port # | Destination Port # |
| --- | --- |
| **Length** | **Checksum** |
| **Application Data (Message)** |  |

> 전체 UDP 헤더 크기: 8바이트(고정)
> 
> 
> TCP보다 훨씬 단순하며, 최소한의 제어 정보만 포함한다.
> 

### UDP 체크섬 (Checksum)

- 송신자가 모든 16비트 단위 데이터를 더해 1의 보수를 취함
- 수신자는 같은 방식으로 합산하여
    - 결과가 `1111111111111111` → 정상
    - `0` 포함 → 오류 발생
- 오류 감지는 하지만 **재전송(복구)은 하지 않음**

### UDP의 신뢰성 확장

- UDP 자체는 비신뢰적이지만, **상위 애플리케이션에서 신뢰성 구현 가능**
    
    → 예: Google **QUIC**
    
    - UDP 위에서 작동
    - 자체 **재전송, 혼잡 제어, 암호화**를 구현
    - HTTP/3의 기반 프로토콜
