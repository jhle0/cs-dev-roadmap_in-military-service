# 2.1-5 네트워크 계층

> Active recall
> 
> - 네트워크 계층의 **주요 역할**은 무엇인가?
> - 트랜스포트 계층과 비교했을 때, **네트워크 계층이 다루는 단위와 대상**은 어떻게 다른가?
> - **포워딩(Forwarding)** 과 **라우팅(Routing)** 의 차이는 무엇인가?
> - 제어 평면(Control Plane)과 데이터 평면(Data Plane)은 각각 어떤 일을 담당하는가?
> - 인터넷의 네트워크 서비스 모델은 왜 **Best-Effort**라고 불리는가?
> - 라우터의 **핵심 구성 요소(입력 포트, 스위칭 구조, 출력 포트, 라우팅 프로세서)** 는 각각 어떤 역할을 하는가?
> - **IP의 핵심 기능**은 무엇이며, 왜 신뢰성을 보장하지 않는가?
> - **IPv4 데이터그램 구조**의 주요 필드는 어떤 역할을 하는가?
> - **서브넷(Subnet)** 과 **CIDR 표기법**은 왜 필요한가?
> - **DHCP**는 IP 주소를 어떻게 자동 할당하는가?
> - **NAT**은 왜 등장했으며, 어떤 장단점을 가지는가?
> - **IPv6**는 IPv4와 비교했을 때 어떤 구조적·기능적 차이가 있는가?
> - 라우팅 알고리즘의 **기본 목적**은 무엇인가?
> - **링크 상태(LS)** 방식과 **거리 벡터(DV)** 방식은 어떤 차이가 있는가?
> - 실제 인터넷은 왜 LS와 DV를 **혼합 형태로 사용**하는가?
> - **OSPF**는 어떤 방식으로 동작하며, 내부 라우팅에서 어떤 장점을 가지는가?
> - **BGP**는 왜 “정책 기반 라우팅 프로토콜”이라고 불리는가?
> - **AS(Autonomous System)** 은 무엇이며, 내부(OSPF)와 외부(BGP) 라우팅은 어떤 차이가 있는가?
> - **SDN(Software-Defined Networking)** 은 기존 네트워크 구조와 어떤 점이 근본적으로 다른가?
> - SDN의 **Match + Action** 개념은 전통적 라우팅과 어떻게 다르게 작동하는가?
> - **OpenFlow** 프로토콜의 역할은 무엇인가?
> - SDN이 **클라우드·데이터센터 네트워크**에서 중요한 이유는 무엇인가?
> - **미들박스**는 라우터와 어떤 점에서 다르고, 어떤 문제를 해결하기 위해 등장했는가?
> - **네트워크 관리(Network Management)** 의 핵심 목표는 무엇인가?
> - **SNMP**는 어떤 구조로 동작하며, 어떤 한계를 가지고 있는가?
> - **NETCONF/YANG**은 기존 SNMP와 비교해 어떤 점에서 발전된 기술인가?
> - SDN, NETCONF, YANG은 어떻게 연결되어 **네트워크 자동화**를 실현하는가?

---

## 5.1 네트워크 계층 개요 (Network Layer Overview)

### 역할

- 네트워크 계층은 **송신 호스트에서 수신 호스트까지 데이터를 전달**하는 계층이다.
- 즉, **경로를 결정(라우팅)** 하고, **실제로 패킷을 전송(포워딩)** 한다.
- 이때 사용하는 데이터 단위가 **IP 패킷(데이터그램)** 이다.

> 트랜스포트 계층이 “프로세스 간 통신”이라면,
> 
> 
> 네트워크 계층은 “호스트 간 통신”을 담당한다.
> 

### 네트워크 계층의 두 주요 기능

| 기능 | 설명 | 위치 |
| --- | --- | --- |
| **포워딩 (Forwarding)** | 패킷이 라우터의 입력 포트에 도착했을 때, 올바른 출력 포트로 전달하는 작업 | **데이터 평면 (Data Plane)** |
| **라우팅 (Routing)** | 패킷이 출발지에서 목적지까지 갈 **최적 경로(Route)** 를 결정하는 과정 | **제어 평면 (Control Plane)** |
- **데이터 평면**: 하드웨어에서 실행, 매우 빠른 처리(나노초 단위)
- **제어 평면**: 경로 계산을 위한 소프트웨어 처리, 상대적으로 느림

### 포워딩 테이블 (Forwarding Table)

- 라우터가 패킷을 보낼 때 참조하는 **매핑 정보(목적지 → 다음 홉 포트)**
- 클라우드의 **라우팅 테이블(Route Table)** 이 이 원리 그대로다.

> 즉, “이 IP 대역은 어떤 게이트웨이로 보낼지”를 결정하는 표라고 생각하면 된다.
> 

### 제어 평면의 두 가지 접근 방식

### 전통적 방식 (Per-Router Control)

- 각 라우터가 자체적으로 라우팅 알고리즘을 실행해 포워딩 테이블을 계산한다.
- 라우터끼리 경로 정보를 교환(OSPF, BGP 등).

> “각자 알아서 계산하는 분산 구조”
> 

### SDN 방식 (Software-Defined Networking)

- **라우팅 계산을 중앙 컨트롤러가 담당**, 라우터는 단순히 지시만 따름.
- **포워딩과 제어를 분리**하여 효율적인 관리 가능.

> SDN은 “네트워크의 제어를 소프트웨어적으로 중앙화”한 방식으로,
> 
> 
> 현대 클라우드 인프라의 핵심 기술이다.
> 

### 네트워크 서비스 모델 (Network Service Model)

네트워크 계층이 제공할 수 있는 서비스의 예시는 다음과 같다.

| 서비스 유형 | 설명 |
| --- | --- |
| **보장된 전달 (Guaranteed Delivery)** | 패킷이 목적지까지 반드시 도착하도록 보장 |
| **지연 보장 (Guaranteed Delay)** | 일정 시간(예: 100ms 이하) 안에 전달 보장 |
| **순서 보장 (Ordered Delivery)** | 송신 순서대로 패킷 도착 보장 |
| **최소 대역폭 보장 (Minimum Bandwidth Guarantee)** | 특정 전송 속도를 보장하여 안정된 처리율 확보 |
| **보안 서비스 (Security Service)** | 출발지 암호화, 목적지 복호화를 통한 기밀성 보장 |

하지만 **인터넷의 실제 IP 계층은 이를 제공하지 않는다.**

### 인터넷 네트워크 계층의 실제 서비스

- 인터넷의 IP 계층은 **최선형 서비스 (Best-Effort Service)** 만 제공한다.
- 즉, 다음은 **보장되지 않는다**:
    - 패킷이 반드시 목적지에 도착함을 보장하지 않음
    - 도착 순서가 유지되지 않을 수 있음
    - 지연 시간에 상한이 없음
    - 대역폭이 일정하지 않음

> IP는 “최선형(Best-Effort)” 원칙만 따르지만,
> 
> 
> 그 단순성과 확장성 덕분에 오늘날 대부분의 네트워크를 구성하고 있다.
> 

---

## 5.2 라우터 (Router)

### 개요

- **라우터(Router)** 는 네트워크 계층의 핵심 장비로,
    
    **IP 패킷을 한 링크에서 다음 링크로 전달(포워딩)** 하는 역할을 수행한다.
    
- 라우터는 **데이터 평면(data plane)** 의 중심에서 실제 **포워딩을 실행**한다.

> 라우터는 “패킷이 지나가는 고속 교차로” 역할을 한다.
> 

### 라우터의 주요 구성 요소

| 구성 요소 | 역할 |
| --- | --- |
| **입력 포트(Input Port)** | 패킷 수신, 헤더 검사, 포워딩 테이블 조회, 큐잉 수행 |
| **스위칭 구조(Switching Fabric)** | 입력 포트에서 출력 포트로 패킷을 실제로 이동시키는 내부 네트워크 |
| **출력 포트(Output Port)** | 패킷 스케줄링, 큐잉, 링크 계층으로 전달 |
| **라우팅 프로세서(Routing Processor)** | 라우팅 테이블 관리, 제어 평면 실행 (OSPF, BGP, SDN 제어 포함) |

### 입력 포트 (Input Port)

- 라우터의 **물리적 수신 지점**
- 주요 기능
    - **헤더 검사(Header Check):** IP 헤더의 목적지 주소 추출
    - **포워딩 테이블 조회:** 목적지 주소를 기반으로 **출력 포트 결정**
    - **큐잉(Queueing):** 스위칭 구조로 즉시 전달할 수 없는 경우 입력 대기열에 저장
- 일부 고속 라우터는 입력 포트 단에서 **병렬 포워딩 테이블 캐싱**(Fast Path)을 사용

### 스위칭 구조 (Switching Fabric)

- 라우터 내부의 **데이터 이동 통로(백본)**
- **입력 포트 → 출력 포트** 간 실제 전송 경로
- 스위칭 구조 성능이 라우터 **처리 속도(Throughput)** 를 결정한다.

> 고속 네트워크에서는 병목을 최소화하기 위해 병렬 스위칭 구조를 사용한다.
> 

### 출력 포트 (Output Port)

- **스위칭 구조로부터 패킷을 받아 링크 계층으로 전송**
- 주요 기능:
    - **패킷 버퍼링(Buffering):** 트래픽 혼잡 시 임시 저장
    - **스케줄링(Scheduling):** 어떤 패킷을 먼저 전송할지 결정
    - **링크 계층 처리:** MAC 헤더 추가 및 전송

### 큐잉(Queueing)과 버퍼링(Buffering)

- **입력 포트와 출력 포트 모두에서 발생 가능**
- **입력 큐(Input Queue):** 스위칭 구조가 바쁠 때 대기
    - “Head-of-Line (HOL) Blocking” → 앞 패킷이 막혀 뒤 패킷 대기
- **출력 큐(Output Queue):** 여러 입력 포트가 동일 출력으로 몰릴 때 대기
    - 버퍼 부족 시 **패킷 손실(Drop)** 발생
    - TCP는 이를 손실로 감지해 **혼잡 제어**를 수행

> 네트워크 지연이나 손실의 주요 원인은 큐 혼잡과 버퍼 오버플로이다.
> 

### 패킷 스케줄링(Packet Scheduling)

| 알고리즘 | 설명 |
| --- | --- |
| **FIFO (First In First Out)** | 먼저 도착한 패킷을 먼저 전송 |
| **Priority Queuing** | 높은 우선순위 패킷을 먼저 처리 (예: 음성 트래픽) |
| **Round Robin / Fair Queuing** | 여러 큐를 순환하며 공평하게 전송 |
| **Weighted Fair Queuing (WFQ)** | 각 흐름에 가중치를 부여해 공정성 향상 |

---

## 5.3 인터넷 프로토콜 (Internet Protocol, IP)

### 개요

- **IP(Internet Protocol)** 은 네트워크 계층의 핵심 프로토콜로,
    
    데이터를 **출발지 → 목적지 호스트**까지 전달하기 위한 **주소 지정 및 포워딩 규칙**을 정의함.
    
- IP는 “**Best-Effort Delivery**” 방식을 따르며, **신뢰성·순서·지연 보장 없음**.
    
    (→ 상위 계층 TCP가 신뢰성을 보완함)
    

### IPv4 데이터그램 구조

| 필드 | 설명 |
| --- | --- |
| **Version (4bit)** | IP 버전을 지정 (IPv4는 4) |
| **Header Length (4bit)** | 헤더의 실제 길이 (옵션 포함 시 가변) |
| **Type of Service (TOS)** | 패킷의 우선순위/서비스 구분 (QoS에 활용) |
| **Total Length (16bit)** | 데이터그램 전체 길이 (최대 65,535B) |
| **Identifier / Flags / Fragment Offset** | 단편화(Fragmentation) 관련 필드 |
| **TTL (Time To Live)** | 패킷의 생존 시간. 라우터 통과 시마다 감소, 0이면 폐기 |
| **Protocol** | 상위 프로토콜 지정 (TCP=6, UDP=17 등) |
| **Header Checksum** | 헤더 오류 검출 (라우터마다 재계산) |
| **Source IP / Destination IP** | 출발지와 목적지 주소 |
| **Options** | 확장 기능 (거의 사용되지 않음) |
| **Data (Payload)** | 트랜스포트 계층 세그먼트 등 실제 데이터 |

### IPv4 주소와 서브넷

- **IP 주소는 호스트가 아니라 인터페이스(interface)에 할당됨**
    
    → 하나의 장비가 여러 네트워크에 연결될 수 있음 (라우터 등)
    
- **서브넷(Subnet)**: 라우터 없이 직접 통신 가능한 네트워크 구간
    - 예: `192.168.0.0/24` → 같은 네트워크 안에서 라우팅 없이 통신 가능
- **CIDR 표기 (a.b.c.d/x)**
    - `/x`는 네트워크 부분의 비트 수
    - 더 유연하게 IP 주소 공간을 나눌 수 있게 함

> 실무 적용 예시: 클라우드 VPC 설계 시 10.0.0.0/16을 만들고 /24 단위로 서브넷을 분리.
> 

### DHCP (Dynamic Host Configuration Protocol)

- 호스트가 **자동으로 IP 주소를 할당받는 프로토콜**
- 추가 정보(서브넷 마스크, 게이트웨이, DNS 서버 등)도 함께 제공
- **4단계 과정:**

| 단계 | 설명 |
| --- | --- |
| ① **DHCP Discover** | 클라이언트 → 네트워크로 브로드캐스트(255.255.255.255) |
| ② **DHCP Offer** | 서버 → 사용 가능한 IP 제안 |
| ③ **DHCP Request** | 클라이언트 → 특정 서버 선택 |
| ④ **DHCP ACK** | 서버 → IP 주소 및 설정 확정 |

> 장점: 자동 구성 (Plug and Play)
> 
> 
> 단점: 이동 시 새 서브넷에서 IP 변경 → 기존 TCP 연결 끊김
> 

### NAT (Network Address Translation)

- **사설 네트워크(Private Network)** 내 여러 호스트가 **하나의 공인 IP**로 외부 통신 가능하게 함
    - 내부 주소 예시: `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`
    - 외부로는 라우터가 **단일 IP(예: 138.76.29.7)** 로 대표함
- 장점:
    - IP 절약 (공인 IP 하나로 여러 장비 사용)
    - 내부 네트워크 보호 (외부에서 직접 접근 어려움)
- 단점:
    - **외부에서 내부로의 접근 제한** → 서버나 P2P 통신 불편
    - 해결: **NAT Traversal (STUN, TURN, UPnP)** 기술

### IPv6 (Internet Protocol Version 6)

### 등장 배경

- IPv4 주소 고갈 → 128bit 주소 공간의 IPv6 등장
- 기존 IPv4 네트워크와 **공존(dual-stack)** 하며 점진적 전환 중

### 주요 변화 (핵심 요약)

| 특징 | IPv4 | IPv6 |
| --- | --- | --- |
| 주소 길이 | 32bit | 128bit |
| 주소 표현 | `192.168.0.1` | `2001:db8::1` |
| 체크섬 | 있음 | 없음 (단순화) |
| 단편화 | 모든 라우터 | 송·수신지에서만 |
| 보안 | 선택적(IPSec) | 기본 내장 |
| QoS | 제한적 | Flow Label로 명시적 지원 |

> IPv6는 “더 많은 주소 + 더 빠른 라우팅 + 보안 기본 탑재”를 목표로 함.
> 

### IPv4 → IPv6 전환 방식

- **터널링(Tunneling)**: IPv6 패킷을 IPv4 패킷 안에 캡슐화해 전달
    
    → IPv4 네트워크 위에서 IPv6 통신 가능
    
- **듀얼 스택(Dual Stack)**: IPv4, IPv6를 모두 지원하는 방식

> 현실적으로 대부분 시스템은 듀얼 스택 상태이며,
> 
> 
> IPv6는 점진적으로 확장 중 (AWS, Google Cloud 등은 완전 지원).
> 

---

## 5.4 소프트웨어 정의 네트워크 (SDN, Software-Defined Networking)

### 개요

- **SDN(Software-Defined Networking)** 은 네트워크의 **제어 평면(Control Plane)** 과 **데이터 평면(Data Plane)** 을 분리한 구조이다.
- 전통적인 라우터는 패킷 전달(포워딩)과 경로 결정(라우팅)을 동시에 수행하지만,
    
    SDN에서는 **제어는 중앙 컨트롤러**, **포워딩은 단순한 스위치**가 담당한다.
    
- 이로써 네트워크를 **소프트웨어적으로 제어**할 수 있으며,
    
    클라우드·데이터센터 환경에서 **자동화·확장성·정책 기반 제어**가 가능해진다.
    

> 기존 네트워크: “각 라우터가 스스로 판단”
> 
> 
> SDN: “컨트롤러가 명령하고 스위치는 따름”
> 

### 기존 네트워크의 한계

1. **하드웨어 중심** – 장비별 수동 설정, 확장 어려움
2. **정책 반영의 어려움** – 특정 트래픽만 차단/허용 같은 세밀한 제어 불가
3. **자동화 부족** – 장애나 트래픽 변화에 실시간 대응 불가

→ SDN은 이런 한계를 해결하기 위해 등장했다.

### SDN의 핵심 구조

| 구성 요소 | 역할 |
| --- | --- |
| **데이터 평면 (Data Plane)** | 스위치·라우터가 **플로우 테이블(Flow Table)** 을 기반으로 패킷을 전달 |
| **제어 평면 (Control Plane)** | 중앙 **SDN 컨트롤러**가 전체 네트워크 상태를 파악하고 플로우 규칙을 계산·배포 |

> 컨트롤러는 “두뇌”, 스위치는 “손발” 역할을 한다.
> 
> 
> (예: OpenFlow 스위치 + ONOS 컨트롤러)
> 

### 플로우 기반 포워딩 (Match + Action)

- 기존 라우터는 목적지 IP만 보고 포워딩했지만,
    
    SDN 스위치는 **다양한 헤더 필드(IP, MAC, 포트, 프로토콜 등)** 를 기준으로 행동을 정의할 수 있다.
    
- 즉, “이런 조건의 패킷이면 이렇게 행동하라”는 규칙을 플로우 테이블에 저장한다.

| 구성 요소 | 설명 |
| --- | --- |
| **Match (매치)** | 패킷 헤더 조건 (예: srcIP, dstPort, MAC, TCP flag 등) |
| **Action (액션)** | 일치 시 수행할 동작 (전송, 수정, 삭제, 드롭 등) |
| **Counter** | 매칭된 패킷 수, 트래픽 통계 |

> “매치 + 액션”은 SDN의 기본 동작 단위이며,
> 
> 
> 이 규칙들은 컨트롤러가 스위치에 **OpenFlow 프로토콜**로 전달한다.
> 

### OpenFlow 프로토콜

- SDN 컨트롤러와 스위치 간 통신을 담당하는 **표준 프로토콜**
- **TCP 포트 6653** 사용
- 컨트롤러는 OpenFlow를 통해 스위치의 플로우 테이블을 원격으로 제어한다.

| 방향 | 명령 예시 | 설명 |
| --- | --- | --- |
| 컨트롤러 → 스위치 | **Modify-State** | 플로우 테이블 엔트리 추가·수정·삭제 |
| 컨트롤러 → 스위치 | **Send-Packet** | 특정 패킷을 지정된 포트로 송신 |
| 스위치 → 컨트롤러 | **Packet-In** | 테이블에 매칭되지 않은 패킷을 컨트롤러로 전송 |
| 스위치 → 컨트롤러 | **Port Status** | 링크 상태 변화 보고 |

> OpenFlow는 컨트롤러가 스위치의 동작을 “프로그래밍”할 수 있도록 해준다.
> 

### SDN 제어 평면의 동작 예시

1. 스위치가 **매칭되지 않은 패킷**을 컨트롤러로 전송 (`Packet-In`)
2. 컨트롤러는 정책 로직에 따라 새로운 경로를 계산
3. 컨트롤러가 **플로우 추가 명령(Modify-State)** 전송
4. 스위치는 새 규칙을 저장하고 이후 같은 패킷은 자체 처리

> 즉, 한 번 학습된 트래픽은 이후 컨트롤러 개입 없이 고속 처리된다.
> 

### SDN의 장점

| 항목 | 설명 |
| --- | --- |
| **유연성** | 네트워크 정책을 코드로 즉시 수정 가능 |
| **자동화** | 장애 발생 시 자동 우회 경로 계산 가능 |
| **중앙 관리** | 모든 장비를 컨트롤러 한 곳에서 통합 제어 |
| **정책 기반 제어** | QoS, 보안, 트래픽 제어를 세밀하게 적용 |
| **확장성** | 클라우드·데이터센터 규모의 네트워크에 적합 |

### 대표 SDN 컨트롤러

| 컨트롤러 | 특징 |
| --- | --- |
| **ONOS (Open Network Operating System)** | “Intent-based” 구조 — 사용자가 “A와 B를 연결”이라고 선언하면 자동 경로 계산 |
| **OpenDaylight (ODL)** | 오픈소스 표준 컨트롤러, 다양한 프로토콜 지원 (OpenFlow, NETCONF 등) |
| **Ryu / Floodlight** | 연구·교육용 경량 컨트롤러, Python 기반 개발 환경 제공 |

### 관련 기술

| 기술 | 설명 |
| --- | --- |
| **NFV (Network Function Virtualization)** | 방화벽·로드밸런서 같은 네트워크 기능을 가상화 환경에서 소프트웨어로 실행 |
| **Intent-based Networking (IBN)** | 사람이 “정책 목표”만 선언하면, SDN 컨트롤러가 자동으로 네트워크 구성을 계산 |

### 핵심 요약

| 항목 | 내용 |
| --- | --- |
| **핵심 개념** | 제어 평면과 데이터 평면 분리 |
| **중앙 제어** | SDN 컨트롤러가 플로우 테이블 계산·배포 |
| **표준 프로토콜** | OpenFlow (TCP 6653) |
| **기술 기반** | Match + Action (플로우 기반 포워딩) |
| **주요 이점** | 자동화, 유연성, 정책 기반 제어 |
| **확장 기술** | NFV, Intent-based Networking |
| **대표 컨트롤러** | ONOS, OpenDaylight, Ryu |

> SDN은 네트워크를 코드처럼 다루는 기술이다.
> 
> 
> 하드웨어 설정 대신, **소프트웨어 로직으로 네트워크를 정의하고 제어**할 수 있게 해준다.
> 
> 현대 클라우드·데이터센터 인프라의 기본이 되는 구조이다.
> 

---

## 5.6 라우팅 알고리즘 (Routing Algorithms)

### 핵심 개념

- **라우팅(Routing)** 은 데이터가 **출발지 → 목적지까지 이동할 최적 경로**를 찾는 과정이다.
- 이 경로 정보를 기반으로 라우터는 **포워딩 테이블(Forwarding Table)** 을 만들어 실제 전달을 수행한다.
- 제어 평면에서 두 가지 방식으로 동작한다:

| 방식 | 설명 | 예시 프로토콜 |
| --- | --- | --- |
| **분산 제어 (Per-Router)** | 각 라우터가 스스로 경로를 계산하고 이웃과 정보 교환 | OSPF, BGP |
| **중앙 제어 (Centralized / SDN)** | 중앙 컨트롤러가 전체 네트워크 경로를 계산·배포 | SDN Controller |

> 라우팅은 네트워크의 “지도”를 만드는 과정이고,
> 
> 
> 포워딩은 그 지도를 따라 “실제로 길을 걷는” 과정이다.
> 

### 라우팅의 기본 원리

- 네트워크는 **노드(라우터)** 와 **링크(연결)** 로 구성된 **그래프 구조**로 볼 수 있다.
- 각 링크는 **비용(cost)** 을 가지며, 이는 거리, 지연, 대역폭 등으로 표현된다.
- 라우터는 **가장 적은 비용의 경로(최단 경로)** 를 선택해 패킷을 전달한다.

### 두 가지 핵심 알고리즘

### 1) 링크 상태(Link-State, LS)

- 모든 라우터가 **네트워크 전체 정보를 공유**하고 각자 최단 경로를 계산한다.
- **다익스트라 알고리즘** 사용 — 각 노드에서 출발하는 최소 비용 경로 트리를 구함.
- 정확하고 빠르지만, 대규모 네트워크에서는 오버헤드가 크다.

> 내부망(AS 내부)에서 사용되는 대표 프로토콜: OSPF
> 

### 2) 거리 벡터(Distance-Vector, DV)

- 각 라우터가 **이웃과 거리 정보를 주고받으며 점진적으로 학습**한다.
- **벨만-포드(Bellman-Ford)** 원리에 따라,
    
    “나에게서 목적지까지의 최단 경로 = (이웃까지의 비용 + 이웃의 거리)” 로 계산한다.
    
- 단순하고 분산적이지만, 오류가 확산되거나 수렴이 느릴 수 있다.

> 외부망(AS 간)에서 사용되는 대표 프로토콜: BGP
> 

### LS vs DV 비교 요약

| 구분 | 링크 상태 (LS) | 거리 벡터 (DV) |
| --- | --- | --- |
| 정보 공유 범위 | 전체 네트워크 | 인접 라우터만 |
| 계산 방식 | 각 라우터가 전체 경로 계산 | 이웃과 반복적 교환 |
| 속도 | 빠르고 정확 | 느릴 수 있음 |
| 확장성 | 대규모에 부적합 | 소규모 네트워크에 적합 |
| 대표 프로토콜 | OSPF | RIP, BGP(유사 구조) |

### 실제 인터넷 구조

- 현실의 인터넷은 **두 방식을 혼합해 사용**한다.
    - 내부(한 조직 내부, AS): **OSPF (링크 상태 방식)**
    - 외부(AS 간): **BGP (거리 벡터 유사 방식)**
- 즉, **기업 내부 네트워크는 LS**,
    
    **ISP 간 트래픽은 DV 원리를 응용한 BGP** 로 동작한다.
    

---

## 5.7 인터넷에서의 AS 내부 라우팅: OSPF (Open Shortest Path First)

### 개요

- **AS(Autonomous System)**: 한 조직(기업, ISP 등)에서 관리하는 라우터 집합
- 동일 AS 내부에서는 하나의 라우팅 프로토콜로 경로를 계산 → **Intra-AS Routing**
- 대표적인 내부 라우팅 프로토콜이 **OSPF (Open Shortest Path First)**
- 외부 간 트래픽 제어는 **BGP**, 내부 트래픽 제어는 **OSPF**

> 즉, OSPF는 “우리 회사 네트워크 안에서 최적 경로를 찾는 지도 제작자”다.
> 

### OSPF의 동작 원리

- **링크 상태(Link-State)** 알고리즘 기반
    - 모든 라우터가 네트워크 전체 토폴로지 정보를 공유
    - 각 라우터는 **다익스트라(Dijkstra)** 알고리즘으로 최단 경로 계산
- **플러딩(Flooding)**: 링크 상태 변화가 있으면 AS 내 모든 라우터에 정보 전파
- IP 계층에서 직접 동작하며 **프로토콜 번호 89**를 사용

> OSPF는 TCP/UDP 위가 아닌, IP 바로 위에서 작동한다.
> 

### 링크 비용 (Cost)

- 경로 선택은 링크 비용에 따라 결정됨
- 관리자가 비용 기준을 조정해 트래픽 흐름을 제어 가능

| 기준 | 설명 |
| --- | --- |
| **홉 수 기준** | 가장 짧은 경로 선택 |
| **대역폭 기반** | 대역폭이 큰 링크를 우선 사용 |
| **정책 기반** | 특정 링크 회피 또는 우선 사용 설정 가능 |

### 주요 특징

| 기능 | 설명 |
| --- | --- |
| **링크 상태 기반 라우팅** | 전체 네트워크 정보를 공유하고 각자 최단 경로 계산 |
| **보안 지원** | 인증 기능 제공 (OSPF 라우터 간 신뢰 확보) |
| **ECMP (Equal-Cost Multipath)** | 동일 비용 경로 여러 개를 병렬 사용하여 부하 분산 |
| **계층 구조 지원 (Area 구조)** | 대규모 네트워크를 구역으로 나누어 관리 (Area 0 = Backbone) |

> 계층 구조를 통해 대규모 네트워크에서도 라우팅 부하를 줄이고 확장성을 확보한다.
> 

---

## 5.8 인터넷 서비스 제공업자(ISP) 간의 라우팅: BGP (Border Gateway Protocol)

### 핵심 개요

- 인터넷은 수많은 **AS(Autonomous System, 자율 시스템)** 으로 구성되어 있다.
    
    → 각 AS는 기업, ISP, 기관 등 **하나의 독립된 네트워크 집단**이다.
    
- AS 내부는 **OSPF** 같은 내부 라우팅 프로토콜로 통신하고,
    
    AS 간에는 **BGP (Border Gateway Protocol)** 로 경로를 교환한다.
    
- **BGP는 전 세계 인터넷을 연결하는 글로벌 표준 라우팅 프로토콜**이다.

> BGP는 “전 세계 수십만 개의 네트워크를 서로 연결하는 인터넷의 핵심 신경망”이다.
> 

### BGP의 역할

1. **경로 광고 (Route Advertisement)**
    - 각 AS는 자신이 관리하는 **주소 범위(프리픽스)** 를 전 세계에 알린다.
    - 예: “내가 203.0.113.0/24 대역을 보유하고 있다.”
2. **최적 경로 선택 (Path Selection)**
    - 여러 경로가 존재할 때, **정책과 경로 속성**을 기반으로 가장 적합한 경로를 선택한다.

> BGP는 “가장 빠른 길”이 아니라, “내가 정한 정책에 맞는 길”을 고른다.
> 

### BGP 연결 구조

| 구성 요소 | 역할 |
| --- | --- |
| **게이트웨이 라우터 (Gateway Router)** | AS 경계에서 외부 AS와 직접 연결 |
| **내부 라우터 (Internal Router)** | 같은 AS 내부에서 트래픽을 전달 |
| **eBGP (External BGP)** | 서로 다른 AS 간 연결 |
| **iBGP (Internal BGP)** | 동일 AS 내 라우터 간 연결 |

> BGP는 TCP 179 포트를 사용하며, 지속적인 세션(TCP 연결) 위에서 동작한다.
> 

### BGP 경로 정보의 핵심 속성

| 속성 | 의미 |
| --- | --- |
| **AS-PATH** | 해당 경로가 거치는 AS들의 목록 (루프 방지, 경로 선택에 사용) |
| **NEXT-HOP** | 다음 AS로 나가는 라우터의 IP 주소 |
| **LOCAL PREF** | AS 내부 정책에 따른 선호도 (값이 클수록 우선) |
| **MED** | 여러 진입점 중 우선순위를 제시하는 힌트 |

> BGP는 거리 대신 “AS-PATH + 정책 값(LocalPref)”으로 경로를 결정한다.
> 

### 경로 선택의 핵심 개념: **뜨거운 감자 라우팅 (Hot-Potato Routing)**

- 여러 경로 중 **내부 비용이 가장 작은(가까운)** 게이트웨이를 선택해
    
    가능한 빨리 외부로 트래픽을 넘긴다.
    

> “패킷을 오래 들고 있지 말고, 가장 가까운 출구로 보내라.”
> 

### 정책 기반 라우팅 (Policy-Based Routing)

- BGP는 단순히 최단 경로를 찾는 것이 아니라,
    
    **사업적 관계와 정책**을 반영해 경로를 결정한다.
    

| 관계 | 설명 |
| --- | --- |
| **Customer (고객)** | ISP로부터 인터넷 연결을 구매하는 쪽 |
| **Provider (제공자)** | 인터넷 연결을 판매하는 ISP |
| **Peer (피어)** | 서로의 고객 트래픽만 교환하는 대등 관계 |

> ISP들은 자신에게 수익이 없는 “제3자 트래픽”은 중계하지 않는다.
> 
> 
> 즉, BGP는 기술보다 **비즈니스 논리**가 더 강한 프로토콜이다.
> 

### IP 애니캐스트 (Anycast)

- 하나의 IP 주소를 **여러 지역 서버에 동시에 할당**
    
    → 사용자는 가장 가까운 서버(AS-PATH이 짧은 곳)로 자동 연결된다.
    
- 대표 사례:
    - DNS 루트 서버
    - Cloudflare, Google DNS 등 글로벌 서비스

> Anycast는 “하나의 IP, 여러 실제 서버” 개념으로,
> 
> 
> BGP의 경로 선택 알고리즘을 그대로 활용한다.
> 

### OSPF vs BGP 요약 비교

| 구분 | **OSPF (Intra-AS)** | **BGP (Inter-AS)** |
| --- | --- | --- |
| 목적 | 내부 네트워크 최적 경로 | 전 세계 네트워크 간 연결 |
| 기준 | 비용(속도·거리 중심) | 정책(AS 관계·비용 중심) |
| 구조 | 링크 상태 기반 | 거리 벡터 + 정책 기반 |
| 사용 계층 | 기업·기관 내부 | ISP 간, 글로벌 트래픽 |
| 대표 특징 | 빠른 수렴, 단순 | 정책 기반, 확장성 뛰어 |

---

## 5.9 인터넷 제어 메시지 프로토콜 (ICMP, Internet Control Message Protocol)

### 개요

- **ICMP**는 IP 계층에서 **호스트와 라우터 간의 오류 및 제어 메시지 교환**을 담당하는 프로토콜이다.
- 일반 데이터 전송에는 사용되지 않고,
    
    **네트워크 진단(Ping, Traceroute)** 과 **오류 보고**에 활용된다.
    
- ICMP 메시지는 **IP 데이터그램 내부(IP 페이로드)** 로 전송되며,
    
    IP 헤더의 **Protocol 번호는 1번**이다.
    

> ICMP는 “IP의 상태 보고 시스템”이자, 네트워크의 건강 상태를 점검하는 신호 체계다.
> 

### 메시지 구조

- 모든 ICMP 메시지는 다음 필드를 포함한다:

| 필드 | 설명 |
| --- | --- |
| **Type** | 메시지의 종류 (예: 요청, 응답, 오류 등) |
| **Code** | 세부 유형 (예: 네트워크 불가, 포트 불가 등) |
| **Checksum** | 오류 검출용 |
| **Data** | 원인이 된 IP 헤더 + 데이터 일부 포함 |

> 이 구조 덕분에 송신자는 “어떤 패킷이 문제였는지” 정확히 확인할 수 있다.
> 

### 주요 ICMP 메시지

| Type | Code | 의미 |
| --- | --- | --- |
| **0** | 0 | Echo Reply (에코 응답) |
| **3** | 다양 | Destination Unreachable (목적지 도달 불가) |
| **8** | 0 | Echo Request (에코 요청) |
| **11** | 0 | Time Exceeded (TTL 초과) |
| **12** | 0 | Parameter Problem (잘못된 헤더) |

### Ping (네트워크 생존 확인)

- **Ping**은 ICMP의 가장 대표적인 활용 예이다.
1. 송신자가 **Echo Request(Type 8)** 메시지를 전송
2. 수신자가 **Echo Reply(Type 0)** 로 응답
3. 송신자는 응답이 돌아올 때까지의 시간을 계산해 **RTT(Round Trip Time)** 출력

> Ping = “ICMP 에코 요청/응답을 이용한 연결 확인 및 지연 측정”
> 

### Traceroute (경로 추적)

- **Traceroute**는 패킷이 거치는 라우터 경로를 추적한다.

**동작 원리**

1. TTL=1부터 시작하여 점진적으로 증가시키며 UDP 세그먼트를 전송
2. 각 라우터는 TTL이 0이 되면 **ICMP Time Exceeded(Type 11)** 메시지를 반환
3. 송신 측은 이 응답의 **발신 IP** 를 기록해 경로를 알아낸다
4. 마지막 목적지에서는 **ICMP Destination Unreachable(Type 3, Code 3)** 로 종료

> Traceroute = “TTL 초과 메시지를 이용한 경로 추적”
> 

### 정리

| 항목 | 내용 |
| --- | --- |
| **프로토콜 이름** | ICMP (Internet Control Message Protocol) |
| **계층 위치** | 네트워크 계층(IP) 바로 위 |
| **주요 기능** | 오류 보고, 경로 탐색, 연결 확인 |
| **대표 명령** | Echo Request/Reply, Destination Unreachable, Time Exceeded |
| **프로토콜 번호** | 1 |
| **주요 활용** | Ping, Traceroute |

> ICMP는 “데이터를 보내는 프로토콜”이 아니라
> 
> 
> “데이터가 제대로 전달되는지를 알려주는 프로토콜”이다.
> 
> 즉, IP 네트워크의 **진단과 오류 보고를 담당하는 신경계**이다.
> 

---

## 5.10 네트워크 관리와 SNMP, NETCONF/YANG

### 개요

- **네트워크 관리(Network Management)** 는 네트워크의 **성능, 안정성, 서비스 품질(QoS)** 을 유지하기 위한
    
    **감시(Monitoring)** · **설정(Configuration)** · **분석(Analysis)** · **제어(Control)** 활동이다.
    
- 관리자는 네트워크 장비(라우터, 스위치, 서버 등)의 상태를 확인하고, 원격으로 제어하며, 장애를 예방한다.
- 현대 네트워크 관리의 핵심은 **자동화(Automation)** 와 **중앙 관리(Centralized Control)** 이다.

> 네트워크 관리의 목적: “서비스가 안정적으로 동작하도록, 최소한의 인력으로 효율적으로 관리하는 것”
> 

### 네트워크 관리의 구성 요소

| 구성 요소 | 역할 |
| --- | --- |
| **관리 서버 (Manager)** | 중앙 제어 시스템. 모든 장비의 상태를 수집·분석·설정 명령 수행 |
| **에이전트 (Agent)** | 각 장비 내부에서 동작하며, 상태 정보를 보고하고 명령을 수행 |
| **관리 데이터 (MIB, YANG)** | 장비의 상태·설정 정보를 표현하는 데이터 모델 |
| **관리 프로토콜 (SNMP, NETCONF)** | 관리 서버 ↔ 장비 간 통신 규약 |

> 쉽게 말해, “관리 서버가 네트워크 장비의 API를 호출해 상태를 조회하고 제어하는 구조”이다.
> 

### 네트워크 관리의 발전 흐름

| 세대 | 방식 | 특징 |
| --- | --- | --- |
| **1세대: CLI (Command Line)** | SSH/Telnet으로 장비 접속 후 수동 명령 입력 | 단순하지만 자동화 불가 |
| **2세대: SNMP (Simple Network Management Protocol)** | 장비의 **MIB 데이터베이스**를 조회/설정 | 표준화된 관리 구조 도입 |
| **3세대: NETCONF + YANG** | XML/JSON 기반 데이터 모델을 이용한 설정 자동화 | SDN·클라우드 환경에 적합 |

### SNMP (Simple Network Management Protocol)

- **SNMP**는 가장 널리 사용되는 네트워크 관리 프로토콜
- 관리 서버가 장비의 상태를 요청(`Get`), 변경(`Set`), 또는 에이전트가 알림(`Trap`)을 보냄
- **UDP 기반**으로 동작하며, 경량·단순하지만 신뢰성은 낮다.

| 동작 | 설명 |
| --- | --- |
| **Get / Set** | 관리 서버가 장비의 MIB 데이터를 요청하거나 수정 |
| **Trap** | 장비가 장애나 이벤트 발생 시 관리자에게 즉시 알림 |

> SNMP는 “서버가 장비의 상태를 폴링(polling)하거나, 이벤트를 트랩으로 받는 방식”이다.
> 

### MIB (Management Information Base)

- **SNMP에서 관리되는 모든 정보의 데이터베이스 구조**
- 트리(Tree) 형태로 정의되어 있으며, 각 노드는 고유한 **OID(Object Identifier)** 를 가짐
- 예시:
    - 시스템 이름 (`sysName`)
    - 네트워크 인터페이스 상태 (`ifStatus`)
    - 트래픽 통계 (`ifInOctets`, `ifOutOctets`)

> MIB = “장비 내부의 표준화된 상태 변수 집합”
> 
> 
> 즉, SNMP는 MIB를 읽고 쓰는 인터페이스이다.
> 

### NETCONF (Network Configuration Protocol)

- **NETCONF**는 SNMP의 한계를 보완하기 위해 등장한 최신 관리 프로토콜
- **XML** 또는 **JSON** 구조로 데이터를 교환하며,
    
    **TLS/SSH 보안 채널**을 통해 설정·조회·수정 작업을 수행한다.
    
- 장비 간 통신은 **RPC(Remote Procedure Call)** 형태로 수행된다.

| 명령 | 설명 |
| --- | --- |
| `<get>` | 장비의 상태나 통계 조회 |
| `<edit-config>` | 설정 변경 |
| `<copy-config>` | 설정 복제 |
| `<delete-config>` | 설정 삭제 |

> NETCONF는 단순 조회뿐 아니라 “실제 설정 변경을 안전하게 수행하는 표준”이다.
> 
> 
> SDN 환경에서 자동화된 네트워크 관리의 기반이 된다.
> 

### YANG (Yet Another Next Generation)

- **YANG**은 NETCONF에서 사용하는 **데이터 모델링 언어**
- 각 장비의 설정, 상태, 통계를 **트리 구조로 정의**한다.
- XML 또는 JSON으로 직렬화되어 NETCONF와 함께 사용된다.

**예시**

```
module example-interface {
  container interface {
    leaf name { type string; }
    leaf speed { type uint32; }
    leaf status { type boolean; }
  }
}

```

> YANG은 “네트워크 장비의 상태를 표현하는 공통 언어”이다.
> 
> 
> 즉, 장비 제조사와 상관없이 같은 구조로 데이터를 다룰 수 있다.
> 

### SNMP vs NETCONF/YANG 비교

| 항목 | SNMP | NETCONF/YANG |
| --- | --- | --- |
| **데이터 형식** | 단순 Key-Value (MIB, OID) | 구조화된 XML/JSON (YANG 모델) |
| **통신 프로토콜** | UDP (비신뢰성) | TCP + SSH/TLS (신뢰성, 보안성 높음) |
| **기능 초점** | 상태 모니터링 중심 | 설정·제어·자동화 중심 |
| **확장성** | 낮음 | 높음 (SDN 환경에 적합) |

### 핵심 요약

| 항목 | 내용 |
| --- | --- |
| **SNMP** | UDP 기반 단순 관리 프로토콜, MIB 데이터 조회 중심 |
| **MIB** | SNMP용 표준 장비 상태 데이터베이스 |
| **NETCONF** | XML 기반 설정/조회 프로토콜 (RPC + 보안 채널) |
| **YANG** | NETCONF용 데이터 모델링 언어 |
| **트렌드** | CLI → SNMP/MIB → NETCONF/YANG (자동화 중심으로 발전) |

> NETCONF/YANG은 SDN 및 클라우드 인프라 환경에서
> 
> 
> “네트워크를 코드처럼 관리(Programmable Network)”하는 핵심 기술이다.
>
