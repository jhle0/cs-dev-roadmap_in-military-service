# 2.1–6 링크 계층 (Data Link Layer)
> Active recall
> 
> - 링크 계층의 역할과 네트워크 계층과의 관계를 직접 설명해보라.
> - 프레이밍(Framing)이란 무엇이며, 왜 필요한가?
> - 링크 계층에서의 오류 검출과 정정은 어떤 원리로 동작하는가?
> - 다중접속 환경에서 충돌(collision)이 발생하는 이유와 이를 해결하는 접근 방식을 설명하라.
> - 스위치(Switch)가 허브(Hub)와 다른 이유를 설명해보라.
> - 스위치가 MAC 주소를 ‘학습(Self-learning)’하는 과정을 단계별로 설명하라.
> - 스위치 네트워크에서 루프(Loop)가 생기면 왜 문제가 되는가?
> - VLAN의 필요성과 동작 방식을 직접 설명해보라.
> - MPLS가 전통적인 IP 포워딩과 다른 점을 설명하라.
> - 데이터센터 네트워크 구조(TOR–Aggregation–Core)를 직접 그리듯 설명하라.
> - 웹페이지 요청 시 실제로 어떤 계층들이 어떤 순서로 동작하는지 말해보라.
---



## 6.1 링크 계층 소개 (Introduction to the Data Link Layer)

### 링크 계층의 역할

- **링크 계층(Data Link Layer)** 은 **인접한 두 노드(한 홉)** 간의 데이터 전송을 담당한다.
- 상위 계층(네트워크 계층)이 IP 패킷을 생성하면, 링크 계층은 이를 **프레임(Frame)** 으로 캡슐화하여 전송한다.
- 프레임은 **헤더(제어 정보)** + **데이터(IP 패킷)** 으로 구성된다.
- 실제 통신은 “출발지 호스트 → 여러 링크 → 목적지 호스트” 순서로 이루어진다.
    
    각 링크마다 링크 계층 프로토콜이 개별적으로 동작한다.
    

### 링크 계층이 제공하는 서비스

1. **프레임화 (Framing)**
    - IP 데이터그램을 프레임으로 감싸 전송한다.
    - 프레임에는 데이터 외에도 송신자·수신자 주소(MAC)와 오류 검출 비트가 포함된다.
2. **링크 접근 제어 (Link Access, MAC Protocol)**
    - 여러 노드가 하나의 매체를 공유할 때 **누가 언제 전송할지**를 조정한다.
        - 매체 접속 프로토콜이 링크상으로 프레임을 전송하 ㄹ규칙을 명시한다
    - 점대점 링크(point-to-point)에서는 단순히 “비어 있으면 전송”.
    - 브로드캐스트 링크에서는 **충돌 방지(CSMA/CD 등)** 기능이 필요하다.
3. **신뢰적 전달 (Reliable Delivery)**
    - 오류 발생 시 **링크 단위에서 재전송**하거나 **ACK/NACK** 방식으로 확인한다.
    - 주로 무선 링크처럼 오류율이 높은 환경에서 사용된다.
    - 대부분의 유선 LAN(Ethernet)에서는 TCP가 신뢰성을 보장하므로 생략된다.
4. **오류 검출 및 정정 (Error Detection and Correction)**
    - 전송 중 잡음이나 신호 감쇠로 비트 오류가 발생할 수 있다.
    - 송신 측은 오류 검출 비트를 추가하고, 수신 측은 이를 검사한다.
    - 일반적으로 하드웨어(NIC) 수준에서 **CRC(Cyclic Redundancy Check)** 로 수행된다.
    - 일부 프로토콜은 오류 위치까지 찾아내 **정정(Correction)** 을 수행할 수 있다.

### 링크 계층의 구현 위치

- **네트워크 인터페이스 컨트롤러 (NIC, Network Interface Controller)(=네트워크 어댑터)**
    - 대부분의 링크 계층 기능은 하드웨어인 **네트워크 어댑터(Network Adapter)** 에 구현된다.
    - 송신 측 NIC: 메모리에 있는 데이터그램을 프레임으로 캡슐화 후 전송
    - 수신 측 NIC: 프레임을 받아 IP 데이터그램을 추출 후 상위 계층으로 전달
- **컨트롤러(Controller)**
    - 네트워크 어댑터 안 컨트롤러는 링크 계층 서비스가 구현된 특수 용도 칩이다.
    - 프레임화, 전송, 오류 검출 등의 기능이 하드웨어 수준에서 수행된다.
- **CPU와 소프트웨어 구성요소**
    - 일부 링크 계층 기능은 소프트웨어로 구현되어 CPU에서 처리된다.
    - 예: 주소 관리, 오류 처리, 컨트롤러 초기화, 데이터 전달 관리 등
---

## 6.2 오류 검출 및 정정 기술 (Error Detection and Correction)

### 개요

- 링크 계층에서는 전송 중 발생할 수 있는 **비트 손상**을 탐지하기 위해 **오류 검출(Error Detection)** 과 **정정(Error Correction)** 기능을 수행한다.
- 대부분의 경우 **하드웨어(NIC)** 가 자동으로 처리하며, 손상된 프레임은 상위 계층(TCP)으로 전달되지 않고 **폐기(drop)** 된다.

### 패리티 검사 (Parity Checking)

- 데이터에 **패리티 비트(1비트)** 를 추가해 1의 개수를 짝수 또는 홀수로 맞추는 방식.
- **단순한 오류 검출**만 가능하며, 짝수 개의 비트 오류는 탐지하지 못한다.
    - 오류가 2개면 그대로이므로 정상으로 나와 검출 X

### 체크섬 (Checksum Method)

- 데이터를 일정 단위로 나누어 모두 더한 뒤,
    
    **1의 보수(One’s Complement)** 값을 헤더에 저장한다.
    
- 수신 측은 데이터를 다시 더해 **모두 1이면 정상**, 그렇지 않으면 오류로 판단한다.
- **TCP/UDP 헤더에서 사용되는 방식**으로, 전송 도중 데이터 손상 여부를 감지한다.
- 소프트웨어 기반으로 수행되며, **CRC보다 검출 정확도는 낮다.**

### 순환 중복 검사 (Cyclic Redundancy Check, CRC)

- 링크 계층에서 가장 널리 쓰는 오류 검출 방식이다. 이더넷 프레임 끝에 붙는 4바이트 FCS(Frame Check Sequence)가 이 CRC 결과다.
- 송신 측은 전송할 비트열을 미리 합의된 **생성 다항식(Generator Polynomial, G)** 으로 나누고, 그때 생기는 나머지를 뒤에 붙여서 보낸다. 이 나머지가 CRC 코드다.
- 수신 측은 받은 전체 비트열을 같은 다항식으로 다시 나눈다. 나머지가 0이면 “전송 중 비트가 안 깨졌다”고 보고 통과시키고, 0이 아니면 오류로 보고 프레임을 버린다.
- 이 과정은 전부 2진수에서의 나눗셈(= XOR 연산)으로 이뤄지기 때문에 하드웨어로 구현하기 쉽다. 그래서 NIC 안에 전용 회로가 들어 있고 CPU가 신경 쓰지 않아도 된다.
- 잘 설계된 CRC는
    - 1비트 오류
    - 짧은 연속 오류(버스트 오류)
    - 대부분의 우연한 비트 뒤섞임
        
        을 매우 높은 확률로 잡아낸다.
        
- 이더넷은 보통 **CRC-32**를 쓰는데, 32비트 코드이기 때문에 우연히 못 잡을 확률이 아주 낮다.
- 중요한 점은 CRC가 “잡아낸다”까지이고, “고친다”까지는 아니다. 수신 NIC가 오류를 발견하면 그 프레임을 그냥 버리고, 손실 복구는 위쪽 계층(TCP 등)이 한다.

---
## 6.3 다중 접속 링크와 프로토콜 (Multiple Access Links and Protocols)

### 두 종류의 네트워크 링크

- **점대점 링크 (Point-to-Point Link)**
    
    두 장치가 한 채널을 단독으로 사용하는 연결 방식.
    
    예: PPP, HDLC
    
- **브로드캐스트 링크 (Broadcast Link)**
    
    여러 노드가 하나의 채널을 공유하여 동시에 전송할 수 있는 구조.
    
    예: 이더넷, 무선 LAN
    

### 다중 접속 문제 (Multiple Access Problem)

브로드캐스트 환경에서는 여러 노드가 동시에 전송하면 **충돌(collision)** 이 발생한다.

충돌이 생기면 프레임이 손상되어 재전송이 필요하고,

이로 인해 **대역폭이 낭비**된다.

이를 해결하기 위해 **다중 접속 프로토콜(Multiple Access Protocol)** 이 사용된다.

- MAP에서 요구되는 2가지 특성
    - 단 하나의 노드이면 최대 전송률인 **R**bps
    - M개의 노드이면 **R/M**bps 전송률

### 채널 분할 프로토콜 (Channel Partitioning Protocols)

**시분할 다중화 (TDM, Time Division Multiplexing)**

- 채널을 시간 단위로 분할해 각 노드가 **순서대로 전송**
- 충돌 없음, 공정함
- 단점: 노드가 없을 때도 시간 슬롯이 낭비됨

**주파수 분할 다중화 (FDM, Frequency Division Multiplexing)**

- 채널 대역폭을 여러 개의 **주파수 대역**으로 나누어 각 노드에 할당
- TDM과 같은 장단점

**코드 분할 다중 접속 (CDMA, Code Division Multiple Access)**

- 각 노드에 **고유 코드**를 부여하여 동시에 전송 가능
- 코드 간 간섭이 적으면 충돌 없이 병렬 전송 가능
- 무선통신(Wi-Fi, 3G), 군사 시스템에서 주로 사용

### 랜덤 접속 프로토콜 (Random Access Protocols)

- 모든 노드가 전송할 때 **최대 전송률인 Rbps로 전송한다**
- 충돌이 발생하면 랜덤한 시간만큼 기다린 뒤 재전송한다.

**슬롯 알로하 (Slotted ALOHA)**

- 시간 슬롯 단위로 전송
- 충돌 시 랜덤 재전송
- 최대 효율: 약 37%

**순수 알로하 (Pure ALOHA)**

- 슬롯 개념 없음, 임의 시점에 전송 시작
- 충돌 확률이 더 높음
- 최대 효율: 약 18%

**CSMA (Carrier Sense Multiple Access)**

- 전송 전 **채널 감지(Carrier Sensing)** 로 충돌을 줄임
- 하지만 전파 지연으로 인해 충돌 완전 제거 불가

**CSMA/CD (CSMA with Collision Detection)**

- 충돌 검출(Collision Detection)을 수행
- **이더넷(Ethernet)** 의 핵심 프로토콜
- 충돌이 감지되면 즉시 전송 중단 후 **랜덤 백오프(Exponential Backoff)**

### 순번 프로토콜 (Taking-Turns Protocols)

**폴링 프로토콜 (Polling Protocol)**

- 하나의 **마스터 노드**가 다른 노드를 순서대로 호출해 전송 기회를 부여
- 장점: 충돌 없음, 효율적
- 단점: 마스터 장애 시 전체 중단, 지연 발생

**토큰 전달 프로토콜 (Token Passing)**

- **토큰(Token)** 이라는 제어 프레임을 순환적으로 전달
- 토큰을 가진 노드만 전송 가능
- 장점: 분산 구조, 효율적
- 단점: 노드 장애나 토큰 분실 시 복구 절차 필요

### DOCSIS: 케이블 인터넷의 다중 접속

**DOCSIS(Data-over-Cable Service Interface Specification)** 은

케이블 인터넷의 물리·링크 계층 표준이다.

**하향 채널 (Downstream)**

- CMTS → 여러 케이블 모뎀으로 데이터 전송
- **브로드캐스트 기반**, 충돌 없음
- FDM으로 주파수 대역 분리

**상향 채널 (Upstream)**

- 여러 케이블 모뎀이 CMTS로 데이터 전송
- **TDM 구조 기반**, 미니슬롯 단위로 전송 시간 분배
- 미니슬롯 요청 충돌 시 **이진 지수적 백오프** 사용

---
## 6.4 스위치 근거리 네트워크 (Link-Layer Switching and LANs)

### 개요

- 스위치는 **링크 계층(2계층)** 에서 동작하며, **MAC 주소**를 기반으로 프레임을 전달한다.
- IP 주소를 이해하지 않기 때문에 **라우팅 알고리즘(OSPF 등)** 은 사용하지 않는다.
- 목적지는 **네트워크 계층(IP)** 이 아닌, **링크 계층 주소(MAC)** 로 결정된다.

### MAC 주소

- 링크 계층에서 사용되는 **물리적 주소(48비트, 6바이트)**
- NIC(네트워크 인터페이스 카드)에 할당되며, **장치마다 고유하다.**
- IP 주소는 위치에 따라 바뀌지만, MAC 주소는 장치가 바뀌지 않는 한 유지된다.
    - 예시) 주민번호 = MAC주소 , 주소 = IP주소, 이름 = 호스트명
- IEEE가 제조사별로 주소 블록을 배정한다 (앞 24비트는 제조사 식별자).
- **표기 방식:** 16진수 6쌍 (예: `00:1A:92:4B:12:AF`)

### MAC 주소 사용 방식

1. 송신 어댑터는 목적지 MAC 주소를 프레임에 포함시켜 전송한다.
2. 수신 어댑터는 자신과 일치하는 MAC 주소면 상위 계층으로 전달, 아니면 폐기한다.
3. 브로드캐스트 주소(`FF:FF:FF:FF:FF:FF`)를 사용하면 LAN의 모든 노드가 수신한다.

### ARP (Address Resolution Protocol)

- **IP 주소 ↔ MAC 주소** 변환을 담당하는 프로토콜
- 동일한 **LAN/Subnet 내** 통신에서만 동작한다.
- 각 장치는 IP–MAC 매핑 정보를 가진 **ARP 테이블**을 관리한다.
    - 항목에는 TTL(Time-To-Live)이 있어 일정 시간이 지나면 삭제된다.

**ARP 동작 과정**

1. 송신 호스트가 목적지 MAC 주소를 모르면, **ARP 요청(브로드캐스트)** 전송
2. 대상 호스트가 자신의 IP와 일치함을 확인하면 **ARP 응답(유니캐스트)** 전송
3. 송신자는 응답을 수신하고 **ARP 테이블에 등록**
4. 이후 동일 목적지로 전송 시, 테이블의 MAC 주소를 이용해 프레임 생성

**특징**

- 네트워크 관리자가 별도 구성하지 않아도 자동으로 동작 (Plug and Play)
- DNS가 “호스트명 → IP 주소” 변환이라면, ARP는 “IP → MAC 주소” 변환

### 서브넷 외부 노드로의 전송

- 목적지가 다른 서브넷에 있을 경우, 프레임은 **라우터의 인터페이스 MAC 주소**로 전송된다.
- 라우터는 IP 헤더의 목적지 주소를 확인하고 다음 홉으로 포워딩한다.
- 따라서, **라우터 인터페이스의 MAC 주소**가 실제 전송 대상이 된다.

### 이더넷 (Ethernet)

### 특징

- 가장 널리 사용되는 **LAN 기술 (IEEE 802.3 표준)**
- 현재는 **스위치 기반의 스타 토폴로지** 구조가 주류다.
- **비연결형(connectionless)**, **비신뢰적(unreliable)** 서비스:
    - 프레임 손실 시 재전송 없음 (TCP가 담당).
    - 프레임 송신 시, ‘헨드셰이킹’ 하지 않음

### 이더넷 프레임 구조

| 필드 | 길이 | 설명 |
| --- | --- | --- |
| **Preamble** | 8B | 송·수신 클록 동기화용 |
| **Destination MAC** | 6B | 수신 어댑터 주소 |
| **Source MAC** | 6B | 송신 어댑터 주소 |
| **Type** | 2B | 상위 프로토콜 식별 (IPv4, IPv6 등) |
| **Data** | 46~1500B | 실제 전송 데이터(IP 데이터그램 등) |
| **CRC** | 4B | 오류 검출용 코드 (링크 계층 수준) |

### 링크 계층 스위치 (Link-Layer Switch)

### 스위치의 역할

- 들어오는 프레임을 읽고 **MAC 주소 기반으로 스위칭(필터링 및 포워딩)**
    - 필터링 - 프레임을 전달할지 폐기할지 결정하는 기능
    - 포워딩 - 프레임이 전소오딜 인터페이스를 결정하고, 내보내는 기능
- 각 스위치는 **스위치 테이블(Switch Table)** 을 유지한다.
    
    (MAC 주소 ↔ 인터페이스 번호 ↔ 타임스탬프)
    

### 스위치의 주요 기능

| 기능 | 설명 |
| --- | --- |
| **필터링(Filtering)** | 프레임을 버릴지, 포워딩할지 결정 |
| **포워딩(Forwarding)** | 특정 인터페이스로 프레임을 전송 |
| **브로드캐스트(Broadcast)** | MAC 주소를 모르면 모든 포트로 전송 |
| **자가 학습(Self-Learning)** | 수신 프레임의 출발지 주소를 테이블에 자동 기록 |

### 스위치의 특성

- 충돌이 없다 (각 포트 독립 세그먼트) → MAC(Multical Access Protocol) 필요 X
- 이질적인 링크(속도·매체)가 공존 가능
- 네트워크 통계·모니터링 용이
- 플러그 앤 플레이 장치 — 별도 설정 불필요

### 스패닝 트리 프로토콜 (Spanning Tree Protocol, STP)

- 스위치 기반 LAN에서는 프레임이 브로드캐스트될 때 **여러 스위치 간에 루프(loop)** 가 존재하면
    
    동일한 프레임이 무한히 순환하면서 네트워크가 마비될 수 있다.
    
- 이를 방지하기 위해 **IEEE 802.1D 스패닝 트리 프로토콜(STP)** 이 사용된다.
- STP는 스위치들 간의 연결 구조를 분석하여 **루프가 생기지 않도록 일부 링크를 자동으로 차단(blocking)** 하고,
    
    논리적으로 **하나의 트리 형태**로 네트워크를 구성한다.
    
- 링크 장애가 발생하면 차단된 링크를 다시 활성화하여 **자동으로 경로를 복구(recovery)** 한다.

> 즉, 스위치는 충돌은 막지만 루프는 막지 못한다.
> 
> 
> STP는 이런 루프를 막기 위한 **링크 계층 수준의 자동화된 보호 메커니즘**이다.
> 

### 가상 근거리 네트워크 (VLAN)

**VLAN의 필요성**

물리적 네트워크 하나를 여러 개의 **논리적 LAN** 으로 분리하기 위함.

- 트래픽 격리 (보안 향상)
- 네트워크 효율성 향상 (브로드캐스트 범위 축소)
- 유연한 사용자 관리 (물리적 이동 없이 VLAN 변경 가능)

**포트 기반 VLAN**

- 스위치 포트를 그룹으로 나누어 VLAN을 구성
- 같은 VLAN 내 포트끼리만 통신 가능
- 서로 다른 VLAN 간 트래픽은 **라우터** 또는 **L3 스위치** 필요

VLAN 트렁킹 (VLAN Trunking)

- 여러 VLAN을 하나의 물리 링크로 연결하기 위한 기술
- 트렁크 포트에는 **VLAN 태그(VLAN Tag, 802.1Q)** 가 추가됨
- VLAN 태그는 송신 스위치에서 추가되고, 수신 스위치에서 제거됨
- 태그 구성:
    - **TPID (2B)**: VLAN 프레임 식별
    - **TCI (2B)**: VLAN ID(12비트) + 우선순위(3비트)

### 스위치 vs 라우터 비교

| 구분 | 스위치 | 라우터 |
| --- | --- | --- |
| **계층** | 2계층 (MAC) | 3계층 (IP) |
| **주소 기반** | MAC 주소 | IP 주소 |
| **플러그 앤 플레이** | O | X |
| **충돌 처리** | 없음 | 없음 |
| **브로드캐스트 제어** | 한계 있음 | 라우팅으로 격리 가능 |
| **사용 예시** | LAN 내부 통신 | VLAN 간 또는 외부 네트워크 연결 |
---

## 6.5 링크 가상화: 링크 계층으로서의 네트워크 (Link Virtualization: A Network as a Link Layer)

### 개요

링크 계층의 확장된 개념으로, **여러 네트워크 경로를 하나의 논리적 링크처럼 사용하는 가상화 기술**을 의미한다.

대표적인 예시가 **MPLS (Multiprotocol Label Switching)** 이다.

MPLS는 전통적인 IP 라우팅 구조를 유지하면서도,

**패킷 전달 속도 향상**, **QoS(품질 보장)**, **트래픽 엔지니어링(경로 제어)** 을 가능하게 한다.

### MPLS의 개념

- 전통적인 IP 라우터는 목적지 IP 주소를 확인하고 **최장 프리픽스 매칭(Longest Prefix Match)** 으로 경로를 찾는다.
- MPLS는 이 과정을 단축하기 위해 **패킷에 고정 길이의 ‘레이블(Label)’을 붙여 전달**한다.
- MPLS 지원 라우터는 **IP 주소를 분석하지 않고** 이 레이블만 보고 빠르게 스위칭한다.
- 이처럼 동작하는 라우터를 **LSR(Label-Switched Router)** 라고 부른다.

**핵심 아이디어**

> IP 라우팅을 완전히 대체하지 않고,
> 
> 
> IP 기반 인프라 위에 “레이블 기반 전달 기능”을 추가한 확장 구조이다.
> 

### MPLS 헤더 구조

MPLS는 2계층 헤더(예: Ethernet)와 3계층 헤더(IP) 사이에 MPLS 헤더를 삽입한다.

| 필드 | 크기 | 설명 |
| --- | --- | --- |
| **Label** | 20bit | 패킷의 논리적 경로 식별자 |
| **Exp** | 3bit | QoS 우선순위 또는 실험용 필드 |
| **S (Bottom of Stack)** | 1bit | 스택된 MPLS 헤더 중 마지막 여부 표시 |
| **TTL** | 8bit | 생존 시간(Time To Live) – 루프 방지용 |
- MPLS 헤더는 **MPLS 지원 라우터 간에만 전송**된다.
- IP 주소를 수정하지 않고 **링크 계층 수준에서 스위칭**한다.

### MPLS 동작 과정

1. **입력 라우터(Ingress LSR)** 가 패킷의 목적지를 확인하고 MPLS 레이블을 부착한다.
2. **중간 라우터(Transit LSR)** 들은 IP 헤더를 보지 않고, 레이블을 기반으로 포워딩 테이블을 조회하여 패킷 전달.
3. **출력 라우터(Egress LSR)** 가 레이블을 제거하고 일반 IP 패킷으로 상위 계층에 전달한다.

→ IP 주소 기반 라우팅보다 빠르고,

**고정 길이 테이블 조회**로 하드웨어 처리 효율이 높다.

### MPLS의 장점

| 기능 | 설명 |
| --- | --- |
| **고속 스위칭** | IP 주소 해석 없이 레이블만으로 포워딩 |
| **트래픽 엔지니어링 (Traffic Engineering)** | 여러 경로를 제어·분산하여 네트워크 효율 향상 |
| **QoS 보장** | Exp 비트를 통해 우선순위 기반 처리 가능 |
| **가상 사설망 (VPN)** | 레이블로 논리적 링크를 구분, 하나의 네트워크 내에 다중 VPN 구성 가능 |

### MPLS와 기존 라우팅의 차이

| 구분 | 전통적 IP 라우팅 | MPLS |
| --- | --- | --- |
| **경로 결정 기준** | 목적지 IP 기반 | 레이블(Label) 기반 |
| **테이블 검색** | 최장 프리픽스 매칭 | 고정 길이 인덱스 검색 |
| **포워딩 속도** | 느림 (소프트웨어 중심) | 빠름 (하드웨어 처리) |
| **경로 제어** | 자동 (단일 최단 경로) | 수동/정책 기반 (트래픽 엔지니어링) |
| **QoS 지원** | 제한적 | 우선순위 기반 패킷 처리 가능 |

### 트래픽 엔지니어링(TE, Traffic Engineering)

- IP 라우팅은 최단 경로만 선택하므로, 특정 경로에 트래픽이 몰릴 수 있다.
- MPLS는 **여러 레이블 경로(Label Switched Path, LSP)** 를 설정하여 부하를 분산시킨다.
- 관리자는 MPLS 네트워크를 통해 특정 트래픽(예: VoIP, DB Sync)을 우선 처리하도록 설정할 수 있다.

---
## 6.6 데이터 센터 네트워킹 (Data Center Networking)

### 개요

데이터 센터는 **대규모 서버(호스트)** 를 고속 네트워크로 연결한 구조로,

클라우드 서비스와 웹 애플리케이션의 핵심 인프라이다.

**3가지 주요 목적**

1. 웹, 이메일, 스트리밍 등 **콘텐츠 제공**
2. 대규모 분산 연산 (검색 엔진 인덱싱 등)
3. **클라우드 컴퓨팅 인프라** 제공 (AWS, GCP, Azure 등)

### 데이터 센터 구조

**호스트(Host)**

- 데이터 센터의 기본 단위 서버 (일반적으로 “**블레이드(Blade)**” 형태).
- **CPU, 메모리, 디스크**를 포함하며, 보통 **랙(rack)** 단위로 배치.
- 각 호스트는 내부 전용 IP 주소를 가짐 (프라이빗 네트워크).

**TOR (Top of Rack) 스위치**

- 각 랙 상단에 위치하며, 같은 랙의 모든 호스트를 연결.
- 상위 스위치(aggregation/core switch)와 연결되어 외부 통신 가능.
- 주로 **1GbE, 10GbE, 40GbE 포트** 사용.

**경계 라우터(Border Router)**

- 외부 인터넷과 데이터 센터 내부 네트워크를 연결.
- 외부 클라이언트 요청이 내부 서버로 들어오는 **입구 게이트웨이 역할.**

**로드 밸런서(Load Balancer)**

- 외부 요청을 여러 내부 서버로 분산시켜 **부하 분산 및 고가용성** 확보.
- **L4 (전송 계층, 포트 기반)** 또는 **L7 (애플리케이션 계층, HTTP 기반)** 으로 동작.
- 내부 서버의 실제 IP를 숨기기 위해 NAT와 유사한 주소 변환 기능 수행.

**장점**

- 부하 균등화, 장애 대응, 보안 강화 (내부 구조 노출 방지).

### 계층적 네트워크 구조

| 계층 | 역할 |
| --- | --- |
| **Access Layer** | TOR 스위치, 호스트 연결 담당 |
| **Aggregation Layer** | 여러 TOR 스위치를 상위 계층으로 연결 |
| **Core Layer** | 상위 네트워크 및 경계 라우터로 연결 (인터넷 트래픽 처리) |
- 호스트들은 **하나의 서브넷(subnet)** 내에서 통신.
- **VLAN 분할**로 브로드캐스트 트래픽을 제한.
- 장애 대비를 위해 **이중화 링크와 스위치** 구성 필수.

### 병목 문제

- 랙 간 트래픽이 많을 경우, 상위 스위치나 링크에서 **대역폭 부족(bottleneck)** 발생.
- 예: TOR ↔ Core 간 링크가 적으면 랙 간 전송 속도 급감.

**해결방안**

- 고속 스위치·링크 사용 (비용 ↑)
- 관련 서비스·데이터를 동일 랙 내에 배치
- **다중 경로 연결(Multipath Connectivity)**
    - TOR ↔ 상위 스위치 간 중복 연결로 **경로 다양성·신뢰성** 확보

### 데이터 센터 네트워킹 동향

**1. 비용 절감 및 스케일 아웃 구조**

- 고가 장비 대신 **다수의 저가 스위치**를 계층적으로 연결.
- 모든 서버가 서로 통신 가능해야 하므로 **풀 메쉬(full-mesh)** 가 아닌 **Clos/Fat-Tree 구조** 사용.

**2. 중앙 집중형 SDN 제어**

- 데이터 센터는 단일 조직이 관리하므로 **SDN(Software-Defined Networking)** 채택이 용이.
- **중앙 컨트롤러**가 스위치의 플로우 테이블을 제어 → 빠른 네트워크 재구성 가능.

**3. 가상화 (Virtualization)**

- **가상머신(VM)** 이나 **컨테이너**가 물리적 서버에서 분리되어 이동 가능.
- VM 이동 시에도 네트워크 연결 유지 필요 →
    
    **가상 네트워크(VXLAN, NVGRE, Geneve 등)** 기술 사용.
    
- ARP 브로드캐스트를 대체하는 **디렉터리 기반 주소 매핑 시스템** 도입.

**4. 물리적 제약**

- 데이터 센터는 **초저지연·고대역폭 환경**에서 운영됨.
- TCP의 일반 혼잡 제어는 부적합 →
    
    **DCTCP (Data Center TCP)**, **RDMA over Ethernet** 등으로 개선.
    

**5. 모듈형 데이터 센터 (Modular Data Center, MDC)**

- **컨테이너 단위**로 조립·운반 가능한 미니 데이터 센터.
- 설치 용이, 확장성 높음.
- 일정 기간 사용 후 노후화되면 교체하는 “소모형 설계” 구조.
- 각 컨테이너는 내부 네트워크 + 컨테이너 간 코어 네트워크로 연결됨.

**6. 지속적 구축 및 커스터마이징**

- 대형 클라우드 기업들은 **직접 하드웨어와 네트워크 스택을 커스터마이징** (예: 구글 Jupiter, AWS Nitro).
- 스위치, 라우터, NIC, SDN 소프트웨어까지 자체 개발.

**7. 고가용성 확보**

- **멀티 AZ(Availability Zone)** 구성: 여러 건물·지역에 데이터 센터 복제.
- 장애 발생 시 자동으로 트래픽 우회 (failover).

---
## 6.7 웹페이지 요청 처리 (요약 순서)

### 1) 네트워크 초기화 — DHCP

1. 노트북이 부팅하고 스위치에 연결한다.
2. 노트북이 **DHCP Discover**를 UDP(68→67), IP 목적지 255.255.255.255, 이더넷 목적지 FF:FF:FF:FF:FF:FF로 브로드캐스트한다.
3. 스위치가 브로드캐스트를 전 포트로 전달하고, 라우터의 DHCP 서버가 이를 수신한다.
4. DHCP 서버가 **DHCP Offer/ACK**로 IP 주소, 서브넷 마스크, **기본 게이트웨이**, **DNS 서버**를 알려준다.
5. 노트북이 설정을 저장하고 “외부 목적지 = 게이트웨이로 보낸다” 규칙을 라우팅 테이블에 등록한다.

### 2) 게이트웨이 MAC 알아내기 — ARP

1. 노트북이 게이트웨이 IP의 **MAC 주소를 알기 위해 ARP 질의**를 브로드캐스트한다.
2. 라우터가 자신의 **MAC**으로 ARP Reply를 유니캐스트한다.
3. 노트북이 ARP 캐시에 게이트웨이 IP–MAC 매핑을 저장한다.

### 3) 도메인 이름 해석 — DNS

1. 노트북이 **DNS 질의(UDP 53)** 를 생성하고, IP 목적지를 “DNS 서버 IP”, **이더넷 목적지는 게이트웨이 MAC**으로 설정해 전송한다.
2. 라우터/ISP 내부 라우팅을 거쳐 DNS 서버에 도달한다.
3. DNS 서버가 **www.example.com → 웹서버 IP**를 담은 응답을 돌려준다.
4. 노트북이 응답에서 **웹서버 IP**를 얻는다.

### 4) 서버와 연결 — TCP 3-way handshake

1. 노트북이 **SYN(목적지 포트 80/443)** 을 보낸다. 이더넷 목적지는 게이트웨이 MAC, IP 목적지는 웹서버 IP이다.
2. 경로상의 라우터들이 **포워딩 테이블**로 다음 홉을 결정하며 전달한다.
3. 웹서버가 **SYN+ACK** 로 응답하고, 노트북이 **ACK** 로 마무리해 **TCP 연결이 성립**한다.

### 5) 콘텐츠 요청/수신 — HTTP

1. 브라우저가 **HTTP GET**(HTTPS라면 TLS 세션 수립 후) 요청을 TCP로 전송한다.
2. 웹서버가 **HTTP 200 OK + 컨텐츠(HTML/CSS/JS/이미지)** 를 세그먼트로 나눠서 보낸다.
3. 노트북의 TCP가 **순서 재조립·오류검사·재전송 처리**를 수행하고, 브라우저가 받은 바이트 스트림을 렌더링한다.

### 6) 후속 동작 — 지속 연결/종료

1. 같은 서버로의 추가 리소스는 **같은 TCP 연결**(HTTP/1.1 Keep-Alive) 또는 **HTTP/2/3의 멀티플렉싱**으로 가져온다.
2. 더 받을 것이 없으면 **FIN/ACK 교환**으로 연결을 종료한다(HTTPS면 세션 정리 포함).
3. 브라우저/OS가 **DNS 결과와 연결**을 캐시에 보관해 다음 요청 지연을 줄인다.

### 메모 (상황별로 추가될 수 있는 것)

- **스위치 자가학습**으로 포트–MAC 매핑이 채워진다.
- **NAT** 환경이면 경계 라우터가 사설 IP:포트를 **공인 IP:포트**로 변환한다.
- 혼잡·손실이 있으면 **TCP 혼잡 제어/재전송**이 전송률을 조절한다.
- HTTPS라면 TCP 직후 **TLS 핸드셰이크**(또는 QUIC(HTTP/3)라면 UDP 기반 **1-RTT** 수립)가 진행된다.
