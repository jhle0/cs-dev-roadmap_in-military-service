# 2.1-8 컴퓨터 네트워크 보안

---

## 8.1 네트워크 보안이란 무엇인가?

### 1. 개요

- 네트워크 보안은 **공개된 네트워크(인터넷)** 위에서도
    
    송신자와 수신자가 **안전하게 통신**할 수 있도록 하는 모든 기술과 절차를 의미한다.
    
- 특히, 제3자인 **침입자(공격자)** 가 통신을 **훔쳐보거나, 바꾸거나, 속이지 못하게** 만드는 것이 핵심이다.

### 2. 안전한 통신에 요구되는 4가지 특성

**1) 기밀성(Confidentiality)**

- **송신자와 지정된 수신자만** 메시지 내용을 이해할 수 있어야 한다.
- 공격자가 메시지를 **도청(snooping)** 하더라도 내용을 해석하지 못하도록
    
    **암호화(encryption)** 를 사용하여 보호한다.
    

**2) 메시지 무결성(Message Integrity)**

- 메시지가 **전송 도중에 변경되지 않았음**을 보장해야 한다.
- 공격자가 메시지를 **수정, 삽입, 삭제** 하더라도
    
    수신자가 이를 **검출**할 수 있어야 한다.
    
    - 예: 해시, MAC(Message Authentication Code) 등을 사용해 확인한다.

**3) 종단점 인증(Endpoint Authentication)**

- 통신 상대가 **진짜 그 사람/그 서버가 맞는지** 확인하는 기능이다.
- 예:
    - 내가 “은행 서버”라고 믿고 접속한 대상이 **실제 은행 서버인지** 또는 공격자인지 확인
    - 로그인 시 ID/비밀번호, 인증서, OTP 등을 이용한 신원 확인

**4) 운영 보안(Operational Security)**

- 오늘날 대부분 기관의 네트워크는 **공공 인터넷과 연결**되어 있다.
- 따라서 외부 공격에 대비해 네트워크 자체에 대한 **운영·관리 보안**이 필요하다.
    - 방화벽 설치
    - 침입 탐지/차단 시스템(IDS/IPS)
    - 접근 제어 정책 설정
- 조직의 네트워크를 **전체 운영 관점에서 어떻게 안전하게 관리할 것인지**에 대한 보안이다.

### 3. 보안 시나리오 구조

**1) 등장 인물**

- **송신자 / 수신자 (앨리스, 밥)**
    - 서로 안전하게 통신하기 위해 **데이터의 일부 또는 전체를 암호화**한다.
    - 위에서 말한 기밀성, 무결성, 인증 특성을 만족시키는 보안 프로토콜을 사용한다.
- **침입자(공격자) (트루디)**
    - 네트워크 채널에 몰래 접근하여 다음과 같은 행동을 시도한다.
        - **스니핑(sniffing)**: 제어 메시지와 데이터 메시지를 **도청·기록**
        - **조작(tampering)**: 메시지 내용 **변경**
        - **삽입(injection)**: 가짜 메시지 **끼워 넣기**
        - **삭제(deletion)**: 특정 메시지 **삭제**
    - 네트워크 보안의 목표는 이런 공격 시도가 있더라도
        
        **통신의 기밀성·무결성·인증·운영 보안**을 유지하는 것이다.
        

---
## 8.2 암호의 원리

### 1. 기본 개념

- **평문(plaintext)**
    
    사람이 읽을 수 있는 **원래 메시지**이다.
    
- **암호문(ciphertext)**
    
    평문을 **암호 알고리즘 + 키**로 변환한 결과이다. 사람이 봐도 의미를 알 수 없다.
    
- **키(key)**
    
    암호화·복호화에 사용하는 **비밀 값**이다.
    
    → 알고리즘 자체는 공개되어 있어도, **키를 모르면 평문을 복원하기 어렵게** 만드는 것이 목표이다.
    

### 2. 대칭키 암호(Symmetric Key)

**1) 개념**

- **같은 키**로 암호화와 복호화를 하는 방식이다.
- 송신자와 수신자가 **미리 비밀키를 안전하게 공유**하고 있어야 한다는 점이 특징이다.

**2) 고전적 예시**

- **카이사르 암호**
    
    알파벳을 일정 칸(k칸)만큼 밀어서 다른 문자로 치환하는 방식이다.
    
    → 키 = “몇 칸 밀었는가”.
    
- **단일 치환 암호**
    
    각 문자를 **다른 문자 하나와 일대일로 대응**시키는 방식이다.
    
    → 문자 빈도 분석으로 깨기 쉽다.
    
- **다중 치환 암호**
    
    위치에 따라 다른 치환표를 쓰는 방식이다.
    
    → 같은 문자라도 위치에 따라 다른 암호문이 나올 수 있다.
    

> 이들은 역사적/교육용 예시이고, 실제 현대 보안에서는 사용하지 않는 수준이다.
> 

**3) 블록 암호와 CBC (현대 대칭키 개념만)**

- 현대 대칭키 암호는 보통 **블록 암호(block cipher)** 를 사용한다.
    - 데이터를 **k비트 블록 단위**(예: 128비트)로 잘라서,
    - 각 블록을 키를 이용해 **다른 k비트 블록으로 변환**한다.
    - 예: AES, (옛날: DES)
- 단순 블록 암호만 쓰면:
    - 동일한 평문 블록 → 항상 같은 암호문 블록이 되어 **패턴이 노출**될 수 있다.
- **CBC(Cipher Block Chaining)** 의 아이디어:
    - “각 블록 암호화에 **이전 암호문 블록을 함께 섞어서** 사용하자”이다.
    - 그래서 같은 평문 블록이라도 **앞의 암호문에 따라 결과가 달라져** 패턴이 숨겨진다.
    - 처음 블록에는 **초기화 벡터(IV)** 라는 임의값을 사용한다.

### 3. 공개키 암호(Public Key)

1) 개념

- **서로 다른 두 개의 키**를 사용한다.
    - **공개키(public key)**: 모두에게 공개해도 되는 키이다.
    - **개인키(private key)**: 소유자만 알고 있는 비밀 키이다.
- 통신 방식:
    - 송신자: 수신자의 **공개키로 암호화**
    - 수신자: 자신의 **개인키로 복호화**

→ 이렇게 하면 **키를 미리 비밀리에 공유할 필요 없이** 안전하게 통신을 시작할 수 있다.

**2) RSA의 핵심 아이디어**

- 대표적인 공개키 암호 알고리즘이 **RSA**이다.
- 큰 수에 대한 **모듈러 연산(나머지 연산)**과
    
    그 수를 다시 소인수분해하는 것이 **매우 어렵다는 성질**에 기반한다.
    
- 공개키 (n, e)는 모두에게 알려져 있지만,
    
    n을 다시 p, q 두 소수로 분해하기가 현실적으로 어렵기 때문에
    
    개인키를 추측하기 힘들다고 보는 것이다.
    

### 4. 하이브리드 암호화(Hybrid Encryption)

- **문제점**
    - 공개키 암호(RSA 등)는 **속도가 느리다**.
    - 대칭키 암호(AES 등)는 **빠르지만**, 키를 공유하는 과정이 문제이다.
- **해결 – 둘을 섞어 사용**
    1. 송신자가 임시 **세션키(대칭키)** 를 하나 만든다.
    2. 이 세션키를 수신자의 **공개키로 암호화**해서 보낸다.
    3. 수신자는 자신의 **개인키로 세션키를 복호화**한다.
    4. 이후 실제 데이터는 이 세션키를 이용해 **대칭키 암호**로 빠르게 암호화한다.

→ 실제 웹의 TLS/HTTPS 같은 프로토콜이 이 구조를 사용한다고 이해하면 된다.

---
