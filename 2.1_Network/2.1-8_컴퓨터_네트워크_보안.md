# 2.1-8 컴퓨터 네트워크 보안

---

## 8.1 네트워크 보안이란 무엇인가?

### 1. 개요

- 네트워크 보안은 **공개된 네트워크(인터넷)** 위에서도
    
    송신자와 수신자가 **안전하게 통신**할 수 있도록 하는 모든 기술과 절차를 의미한다.
    
- 특히, 제3자인 **침입자(공격자)** 가 통신을 **훔쳐보거나, 바꾸거나, 속이지 못하게** 만드는 것이 핵심이다.

### 2. 안전한 통신에 요구되는 4가지 특성

**1) 기밀성(Confidentiality)**

- **송신자와 지정된 수신자만** 메시지 내용을 이해할 수 있어야 한다.
- 공격자가 메시지를 **도청(snooping)** 하더라도 내용을 해석하지 못하도록
    
    **암호화(encryption)** 를 사용하여 보호한다.
    

**2) 메시지 무결성(Message Integrity)**

- 메시지가 **전송 도중에 변경되지 않았음**을 보장해야 한다.
- 공격자가 메시지를 **수정, 삽입, 삭제** 하더라도
    
    수신자가 이를 **검출**할 수 있어야 한다.
    
    - 예: 해시, MAC(Message Authentication Code) 등을 사용해 확인한다.

**3) 종단점 인증(Endpoint Authentication)**

- 통신 상대가 **진짜 그 사람/그 서버가 맞는지** 확인하는 기능이다.
- 예:
    - 내가 “은행 서버”라고 믿고 접속한 대상이 **실제 은행 서버인지** 또는 공격자인지 확인
    - 로그인 시 ID/비밀번호, 인증서, OTP 등을 이용한 신원 확인

**4) 운영 보안(Operational Security)**

- 오늘날 대부분 기관의 네트워크는 **공공 인터넷과 연결**되어 있다.
- 따라서 외부 공격에 대비해 네트워크 자체에 대한 **운영·관리 보안**이 필요하다.
    - 방화벽 설치
    - 침입 탐지/차단 시스템(IDS/IPS)
    - 접근 제어 정책 설정
- 조직의 네트워크를 **전체 운영 관점에서 어떻게 안전하게 관리할 것인지**에 대한 보안이다.

### 3. 보안 시나리오 구조

**1) 등장 인물**

- **송신자 / 수신자 (앨리스, 밥)**
    - 서로 안전하게 통신하기 위해 **데이터의 일부 또는 전체를 암호화**한다.
    - 위에서 말한 기밀성, 무결성, 인증 특성을 만족시키는 보안 프로토콜을 사용한다.
- **침입자(공격자) (트루디)**
    - 네트워크 채널에 몰래 접근하여 다음과 같은 행동을 시도한다.
        - **스니핑(sniffing)**: 제어 메시지와 데이터 메시지를 **도청·기록**
        - **조작(tampering)**: 메시지 내용 **변경**
        - **삽입(injection)**: 가짜 메시지 **끼워 넣기**
        - **삭제(deletion)**: 특정 메시지 **삭제**
    - 네트워크 보안의 목표는 이런 공격 시도가 있더라도
        
        **통신의 기밀성·무결성·인증·운영 보안**을 유지하는 것이다.
        

---
## 8.2 암호의 원리

### 1. 기본 개념

- **평문(plaintext)**
    
    사람이 읽을 수 있는 **원래 메시지**이다.
    
- **암호문(ciphertext)**
    
    평문을 **암호 알고리즘 + 키**로 변환한 결과이다. 사람이 봐도 의미를 알 수 없다.
    
- **키(key)**
    
    암호화·복호화에 사용하는 **비밀 값**이다.
    
    → 알고리즘 자체는 공개되어 있어도, **키를 모르면 평문을 복원하기 어렵게** 만드는 것이 목표이다.
    

### 2. 대칭키 암호(Symmetric Key)

**1) 개념**

- **같은 키**로 암호화와 복호화를 하는 방식이다.
- 송신자와 수신자가 **미리 비밀키를 안전하게 공유**하고 있어야 한다는 점이 특징이다.

**2) 고전적 예시**

- **카이사르 암호**
    
    알파벳을 일정 칸(k칸)만큼 밀어서 다른 문자로 치환하는 방식이다.
    
    → 키 = “몇 칸 밀었는가”.
    
- **단일 치환 암호**
    
    각 문자를 **다른 문자 하나와 일대일로 대응**시키는 방식이다.
    
    → 문자 빈도 분석으로 깨기 쉽다.
    
- **다중 치환 암호**
    
    위치에 따라 다른 치환표를 쓰는 방식이다.
    
    → 같은 문자라도 위치에 따라 다른 암호문이 나올 수 있다.
    

> 이들은 역사적/교육용 예시이고, 실제 현대 보안에서는 사용하지 않는 수준이다.
> 

**3) 블록 암호와 CBC (현대 대칭키 개념만)**

- 현대 대칭키 암호는 보통 **블록 암호(block cipher)** 를 사용한다.
    - 데이터를 **k비트 블록 단위**(예: 128비트)로 잘라서,
    - 각 블록을 키를 이용해 **다른 k비트 블록으로 변환**한다.
    - 예: AES, (옛날: DES)
- 단순 블록 암호만 쓰면:
    - 동일한 평문 블록 → 항상 같은 암호문 블록이 되어 **패턴이 노출**될 수 있다.
- **CBC(Cipher Block Chaining)** 의 아이디어:
    - “각 블록 암호화에 **이전 암호문 블록을 함께 섞어서** 사용하자”이다.
    - 그래서 같은 평문 블록이라도 **앞의 암호문에 따라 결과가 달라져** 패턴이 숨겨진다.
    - 처음 블록에는 **초기화 벡터(IV)** 라는 임의값을 사용한다.

### 3. 공개키 암호(Public Key)

1) 개념

- **서로 다른 두 개의 키**를 사용한다.
    - **공개키(public key)**: 모두에게 공개해도 되는 키이다.
    - **개인키(private key)**: 소유자만 알고 있는 비밀 키이다.
- 통신 방식:
    - 송신자: 수신자의 **공개키로 암호화**
    - 수신자: 자신의 **개인키로 복호화**

→ 이렇게 하면 **키를 미리 비밀리에 공유할 필요 없이** 안전하게 통신을 시작할 수 있다.

**2) RSA의 핵심 아이디어**

- 대표적인 공개키 암호 알고리즘이 **RSA**이다.
- 큰 수에 대한 **모듈러 연산(나머지 연산)**과
    
    그 수를 다시 소인수분해하는 것이 **매우 어렵다는 성질**에 기반한다.
    
- 공개키 (n, e)는 모두에게 알려져 있지만,
    
    n을 다시 p, q 두 소수로 분해하기가 현실적으로 어렵기 때문에
    
    개인키를 추측하기 힘들다고 보는 것이다.
    

### 4. 하이브리드 암호화(Hybrid Encryption)

- **문제점**
    - 공개키 암호(RSA 등)는 **속도가 느리다**.
    - 대칭키 암호(AES 등)는 **빠르지만**, 키를 공유하는 과정이 문제이다.
- **해결 – 둘을 섞어 사용**
    1. 송신자가 임시 **세션키(대칭키)** 를 하나 만든다.
    2. 이 세션키를 수신자의 **공개키로 암호화**해서 보낸다.
    3. 수신자는 자신의 **개인키로 세션키를 복호화**한다.
    4. 이후 실제 데이터는 이 세션키를 이용해 **대칭키 암호**로 빠르게 암호화한다.

→ 실제 웹의 TLS/HTTPS 같은 프로토콜이 이 구조를 사용한다고 이해하면 된다.

---
## 8.3 메시지 무결성과 전자서명

### 1. 메시지 무결성

- 보장하고 싶은 것:
    1. **메시지가 정말 그 출발지에서 왔는가?** (출발지 인증)
    2. **전송 중에 내용이 바뀌지 않았는가?** (내용 무결성)

### 2. 암호화 해시 함수

- 메시지 `m`을 입력하면 **고정 길이 값 H(m)** 을 내는 함수이다.
- 조건:
    - `m`이 조금만 바뀌어도 H(m)은 크게 바뀐다.
    - 서로 다른 두 메시지 `x, y`에 대해 **H(x) = H(y)** 를 찾기 매우 어렵다(충돌 찾기 어려움).
- 예: MD5, SHA 계열 등 (이름 정도만 알면 됨).

### 3. MAC (Message Authentication Code)

**1) 단순 해시만 붙이는 방식의 문제**

- (m, H(m))만 보내면:
    - 공격자도 임의의 `m'`에 대해 H(m')을 계산해서 (m', H(m'))을 만들 수 있음
    - → “누가 보냈는지”를 알 수 없음.

**2) 비밀키를 이용한 MAC**

- 송신자·수신자가 **비밀키 s** 를 공유한다고 가정.
- 송신: (m, H(m + s)) 전송
- 수신: 같은 s로 H(m + s)를 다시 계산해서 첨부된 값과 비교
    
    → 같으면
    
    - 중간에 **변조되지 않았고**,
    - 키 s를 아는 **정상 송신자에게서 온 것**이라고 판단.
- 실제로는 HMAC(SHA-256 등)이 많이 쓰임.

### 4. 전자서명(Digital Signature)

**1) 목적**

- **누가** 이 메시지에 동의/승인했는지 확인
- **정말 그 사람이 서명한 것인지**
- 서명 후 **내용이 바뀌지 않았는지** 확인

**2) 기본 아이디어**

- 공개키/개인키 사용.
- 서명자:
    - 메시지 m에 대해 해시 H(m) 계산
    - **개인키**로 H(m)을 암호화 → 이것이 전자서명.
- 검증자:
    - 서명자의 **공개키**로 서명을 복호화 → h
    - m으로부터 H(m)을 다시 계산
    - 두 값이 같으면
        - 서명자가 **개인키 소유자**임을 확인
        - 메시지가 **변조되지 않았음**을 확인

### 5. MAC vs 전자서명

- **MAC**:
    - 공유된 **비밀키**로 생성
    - 빠르고 가볍지만, 여러 사람이 같은 키를 쓰면 “정확히 누가 만들었는지”는 구분 안 됨.
- **전자서명**:
    - **개인키**로 서명, **공개키**로 누구나 검증
    - 특정 서명자를 정확히 지정 가능 (법적 효력, 계약 등에서 중요).

---
## 8.4 종단점 인증

### 1. 종단점 인증이란?

- **종단점 인증**이란 통신 상대가 **정말 그 사람이(그 호스트가) 맞는지** 네트워크 상에서 신원을 증명하는 작업이다.
- 이메일 사용자–메일 서버처럼, **프로토콜 시작 전에 먼저 인증**을 하고 나서 나머지 작업을 수행하는 구조이다.

### 2. 인증 프로토콜 ap 2.0 — IP 주소 기반 (취약)

- 아이디어:
    - 송신자의 IP 주소가 이미 알려져 있다고 가정하고,
    - 수신자가 **IP 헤더의 출발지 주소가 그 IP인지 확인**하여 인증하려는 방식이다.
- 문제:
    - 누구나 임의의 출발지 IP 주소를 넣어서 패킷을 만들 수 있음 → **IP 스푸핑(IP spoofing)** 가능
    - 따라서 **안전하지 않은 인증 방식**이다.

### 3. 인증 프로토콜 ap 3.0 — 비밀번호 전송 (도청 취약)

- 아이디어:
    - 송신자와 수신자가 **공유된 비밀번호**를 이용해 인증한다.
    - 지메일, 페이스북 등의 **비밀번호 로그인**과 비슷한 형태이다.
- 문제:
    - 비밀번호가 **그대로(또는 쉽게 복원 가능한 형태로) 전송**되면,
    - 침입자가 도청해서 비밀번호를 알아내고 **나중에 그 사람인 척 재사용**할 수 있다.

### 4. 인증 프로토콜 ap 3.1 — 암호화된 비밀번호 (재생 공격 취약)

- 개선:
    - 비밀번호를 평문으로 보내지 않고,
    - 송신자와 수신자가 공유하는 **대칭 비밀키로 비밀번호를 암호화**해서 보낸다.
- 여전히 문제:
    - 침입자가 **암호화된 비밀번호 자체를 도청**해 저장했다가
    - 나중에 그대로 다시 보내면 수신자가 진짜 사용자로 착각함 → **재생 공격(playback attack)** 이다.

### 5. 인증 프로토콜 ap 4.0 — 넌스 기반 챌린지–응답

- **넌스(nonce)**: 프로토콜 수행 동안 **단 한 번만 사용하는 임의의 숫자**이다.

**동작 절차**

1. 송신자가 수신자에게 “나 인증해줘”라는 메시지를 보낸다.
2. 수신자는 임의의 넌스 R을 만들어 송신자에게 보낸다.
3. 송신자는 **공유된 대칭 비밀키**로 R을 암호화한 값 K(R)을 수신자에게 보낸다.
4. 수신자는 자신도 같은 비밀키를 알고 있으므로 R을 암호화해 본 뒤,
    - 받은 값과 같으면 → **상대가 비밀키를 알고 있는 진짜 송신자**라고 판단한다.

**핵심 포인트**

- 매번 **다른 넌스**를 쓰기 때문에,
    - 이전에 도청해 둔 K(R_old)를 그대로 보내도 **이번에는 통하지 않음**
    - → 재생 공격을 막을 수 있다.
- 따라서 ap 4.0은 “**대칭키 + 넌스 기반 챌린지–응답**”으로
    
    **종단점 인증을 안전하게 구현한 사례**이다.
    

---
## 8.5 전자메일의 보안

### 1. 보안을 여러 계층에서 제공하는 이유

- 보안 기능은 **전송·네트워크·트랜스포트·애플리케이션 계층 중 어느 곳에서나** 넣을 수 있다.
- **네트워크 계층(IPsec 등)** 만으로는 “사용자 수준” 보안을 해결하기 어렵다.
    - 예: 쇼핑몰이 “이 사용자가 진짜 이 회원인가?”를 확인하는 데 IP 보안만으로는 부족하다.
- 상위 애플리케이션 계층에서 보안을 넣으면, 그 프로토콜(전자메일 등)을 쓰는 앱들이 그 보안 서비스를 직접 활용할 수 있다.

### 2. 보안 전자메일

**1) 기밀성 (Confidentiality)**

- 메일 내용을 **대칭키(AES, DES 등)** 로 암호화해서 기밀성을 얻는다.
- 하지만 송신자·수신자만 아는 **대칭키를 어떻게 안전하게 공유하느냐**가 문제이다.
- 공개키(RSA)로 메일 전체를 암호화하면 연산량이 너무 크므로, **세션키(대칭키) + 공개키**를 섞어 쓰는 하이브리드 방식을 사용한다.

**하이브리드 암호화 절차(메일 기밀성)**

1. 송신자가 임의의 **대칭 세션키 Ks** 선택
2. Ks로 메시지 m을 암호화 → 암호문 1
3. Ks 자체를 **수신자의 공개키**로 암호화 → 암호문 2
4. (암호문 1, 암호문 2)를 수신자에게 전송
5. 수신자는 자신의 **개인키**로 암호문 2를 복호화해 Ks 획득
6. 얻은 Ks로 암호문 1을 복호화해 m 복원

→ 메일 내용은 빠른 **대칭키 암호**, 세션키 전달은 **공개키 암호**로 처리하는 구조이다.

**2) 송신자 인증 + 메시지 무결성**

- 사용 도구: **해시 함수 + 전자서명**이다.

**절차**

1. 송신자는 메시지 m에 해시 함수 적용 → **H(m)** (요약문) 생성
2. H(m)을 자신의 **개인키**로 암호화 → 전자서명 생성
3. (m, 전자서명)을 수신자에게 전송
4. 수신자는 송신자의 **공개키**로 전자서명을 복호화 → h 얻음
5. 받은 m에 해시 함수 적용 → H(m) 계산
6. h와 H(m)이 같으면
    - 이 서명은 **해당 개인키 소유자**가 만든 것임
    - m이 **전송 중 변조되지 않음**을 동시에 확인

**3) 통합: “서명 후 암호화”**

- 실제 보안 메일은 위 두 과정을 **합쳐서** 처리한다.
1. 먼저 **송신자 인증 + 무결성**을 위해 (m, 전자서명) 꾸러미를 만든다.
2. 이 꾸러미 전체를 하나의 메시지로 보고, **세션키로 암호화 + 세션키를 공개키로 암호화**하는 기밀성 과정을 적용한다.
3. 수신자는 역순으로 복호화 → 서명 검증 → 무결성 확인을 한다.
- 양쪽 모두 서로의 **공개키**를 정확히 알아야 하므로, 실제 환경에서는 **CA(인증기관)** 를 통해 공개키를 인증받는 구조가 필요하다.

### 3. PGP (Pretty Good Privacy)

- PGP는 **보안 전자메일**을 위한 실질적인 소프트웨어 예시이며, 위에서 설명한 **통합 구조와 거의 동일한 방식**을 쓴다.

**PGP의 핵심 특징**

1. 설치 시 사용자별 **공개키/개인키 쌍** 생성
    - 공개키는 웹사이트나 공개키 서버에 올릴 수 있다.
    - 사용자끼리 서로의 공개키에 서명해서 신뢰 관계를 만드는 **web of trust** 구조를 사용한다.
2. **개인키는 비밀번호로 보호**되며, 사용할 때마다 비밀번호로 인증해야 한다.
3. 사용자는 메일에 대해
    - **전자서명만** 하거나,
    - **암호화만** 하거나,
    - **둘 다** 할지 선택할 수 있다.

---
## 8.6 TCP 연결의 보안: TLS

### 1. TLS란?

- **TLS(Transport Layer Security)** 는
    
    **TCP 위에서 동작하는 보안 프로토콜**이다.
    
- 제공 기능:
    - **기밀성**: 암호화로 내용 보호
    - **무결성**: HMAC 등으로 데이터 변조 여부 확인
    - **서버 인증** + 필요하면 **클라이언트 인증**까지 제공하는 프로토콜이다.

### 2. TLS 동작 단계

**1) 핸드셰이크(Handshake)**

- 목적:
    - **서버가 진짜인지 확인**(서버 인증서 + CA)
    - 이후 사용할 **공유 비밀키(세션 키의 기반이 되는 값, MS/PMS)** 를 둘만 알도록 합의
- 방식:
    - 클라이언트와 서버가 **공개키 암호 + 난수(넌스)** 를 사용해
        
        서로만 아는 비밀값(MS)을 공유한다.
        

**2) 키 유도(Key Derivation)**

- 하나의 비밀값(MS/PMS)으로부터:
    - **클라이언트→서버 암호화 키**
    - **서버→클라이언트 암호화 키**
    - 양 방향 **HMAC 키**
- 이렇게 여러 개의 **세션 키**를 만들어 사용한다.

**3) 데이터 전송(Data Transfer)**

- 애플리케이션 데이터는 **TLS 레코드** 단위로 나눠 처리한다.
- 각 레코드에 대해:
    1. **순서번호 + 데이터** 로 HMAC 계산 → 무결성·순서 보장
    2. 그 결과(데이터+HMAC)를 **세션 키로 암호화** 후 TCP로 전송
- 수신 측은 같은 키와 순서번호로 HMAC을 다시 계산해 **위변조/순서 오류 여부**를 검사한다.

**4) 연결 종료**

- 단순히 TCP FIN만 쓰지 않고,
    
    **“종료 레코드”를 TLS 안에서 암호화 + HMAC 검증 후 처리**하여
    
    공격자가 멋대로 세션을 끊는 것을 어렵게 만든다.
    

## 3. 한 줄로 다시 정리

> TLS는 핸드셰이크로 서버를 인증하고 비밀키를 합의한 뒤,
> 
> 
> 그 키로 **레코드 단위 암호화 + HMAC + 순서번호**를 사용해서
> 
> TCP 연결을 **기밀성·무결성·인증이 보장된 연결**로 바꾸는 프로토콜이다.
> 

---
## 8.7 네트워크 계층 보안: IPsec과 가상 사설 네트워크 (개념 위주)

### 1. IPsec이란?

- **IPsec(IP Security)**: **IP 계층**에서 동작하는 보안 프로토콜 모음이다.
- 제공 기능
    - **기밀성**: IP 패킷 페이로드 암호화
    - **출발지 인증**
    - **데이터 무결성**
    - **재생 공격 방지**

### 2. 사설 네트워크 vs VPN

- 과거: 지점 간 통신을 위해 전용 회선/전용 라우터로 **물리적으로 분리된 사설망(private network)** 을 구축했음 → 비용이 매우 큼.
- 오늘날: **VPN(Virtual Private Network)** 을 사용함.
    - 실제 트래픽은 **공용 인터넷**을 지나가지만,
    - 출입구에서 **IPsec으로 암호화**하여
        
        마치 **기관 내부 전용망처럼 안전한 터널**을 만드는 개념이다.
        

### 3. AH vs ESP

IPsec에서 사용하는 두 주요 프로토콜이다.

- **AH (Authentication Header)**
    - 출발지 인증 + 무결성
    - **암호화(기밀성)는 제공하지 않음**이다.
- **ESP (Encapsulation Security Payload)**
    - 출발지 인증 + 무결성 + **기밀성** 제공
    - 실제 구현에서는 거의 **ESP를 사용**한다고 보면 된다.

### 4. SA, SAD, SPD (구성 개념)

- **SA(Security Association)**
    - IPsec에서의 **논리적인 보안 연결 단위**이다.
    - **단방향(one-way)** 이므로 양방향 통신엔 보통 **2개의 SA**를 사용한다.
    - 어떤 알고리즘, 어떤 키로, 어떤 방향 트래픽을 보호할지에 대한 설정을 담는다.
- **SAD(Security Association Database)**
    - 여러 SA 정보를 저장해 둔 **SA 테이블**이다.
- **SPD(Security Policy Database)**
    - “이 패킷은 IPsec을 적용할지 말지, 적용한다면 어느 SA를 쓸지”를 결정하는 **정책 테이블**이다.
    - 요약:
        - **SPD**: 무엇을 보호할지, 어떤 SA를 쓸지 결정
        - **SAD**: 선택된 SA의 구체 설정(알고리즘·키 등)

### 5. IPsec + VPN 동작 개념 (터널 모드 관점)

- 기관 라우터/VPN 게이트웨이가 **원래 IP 패킷 전체를 ESP로 감싸고 암호화**한 뒤,
    
    그 바깥에 **새 IPv4 헤더**를 붙여 인터넷에 보낸다.
    
- 인터넷 상 라우터들은 **겉 IPv4 헤더만 보고 라우팅**하고,
    
    터널 끝단에서 복호화하여 **원래 IP 패킷**을 되살려 내부망에 전달한다.
    
- 결과적으로, 지점 간 트래픽은 **외부에서 내용과 내부 주소 구조가 보이지 않는 암호화 터널**을 통해 이동하게 된다.

### 6. IKE (키 교환 개념만)

- **IKE(Internet Key Exchange)**: IPsec에서
    - SA를 자동으로 설정하고,
    - 필요한 **암호키들을 자동으로 교환/생성**하는 프로토콜이다.
- 큰 그림:
    - 서로의 **인증서(공개키)** 를 이용해 신원을 확인하고,
    - 디피-헬만(Diffie–Hellman) 등으로 **공유 비밀키**를 만든 뒤,
    - 그 비밀키로 여러 IPsec SA에 사용할 **세션 키**들을 유도한다.

---
