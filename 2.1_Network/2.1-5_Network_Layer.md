# 2.1–5 Network Layer

> Active recall
> 
> - What are the **primary responsibilities** of the network layer?
> - Compared to the transport layer, how do the **unit of data and the communication target** differ at the network layer?
> - What is the difference between **forwarding** and **routing**?
> - What do the **control plane** and **data plane** each handle?
> - Why is the Internet’s network service model called **best effort**?
> - What roles do a router’s **key components (input ports, switching fabric, output ports, routing processor)** play?
> - What are the **core functions of IP**, and why doesn’t it provide reliability?
> - What do the **major fields of the IPv4 datagram format** do?
> - Why do we need **subnets** and **CIDR notation**?
> - How does **DHCP** automatically allocate IP addresses?
> - Why did **NAT** emerge, and what are its pros and cons?
> - Compared to IPv4, what **structural and functional differences** does **IPv6** have?
> - What is the **basic objective** of routing algorithms?
> - How do **Link-State (LS)** and **Distance-Vector (DV)** approaches differ?
> - Why does the real Internet use a **hybrid** of LS and DV?
> - How does **OSPF** operate, and what advantages does it have for intra-domain routing?
> - Why is **BGP** called a “**policy-based routing protocol**”?
> - What is an **Autonomous System (AS)**, and how do **intra-domain (OSPF)** and **inter-domain (BGP)** routing differ?
> - How does **SDN (Software-Defined Networking)** fundamentally differ from traditional network architectures?
> - How does SDN’s **match + action** paradigm operate differently from traditional routing?
> - What is the role of the **OpenFlow** protocol?
> - Why is SDN critical in **cloud and data center networks**?
> - How do **middleboxes** differ from routers, and what problems were they introduced to solve?
> - What are the **core goals of network management**?
> - How does **SNMP** operate architecturally, and what limitations does it have?
> - In what ways are **NETCONF/YANG** advancements over SNMP?
> - How do SDN, NETCONF, and YANG connect to enable **network automation**?

---

## 5.1 Network Layer Overview

### Role

- The network layer is responsible for **delivering data from a sending host to a receiving host**.
- Concretely, it **selects paths (routing)** and **moves packets along those paths (forwarding)**.
- The unit of data at this layer is the **IP packet (datagram)**.

> If the transport layer provides “process-to-process communication,”
> 
> 
> the network layer provides “**host-to-host communication**.”
> 

### Two primary functions of the network layer

| Function | Description | Plane |
| --- | --- | --- |
| **Forwarding** | When a packet arrives at a router’s input port, move it to the correct output port. | **Data plane** |
| **Routing** | Determine the **optimal route** for a packet to travel from source to destination. | **Control plane** |
- **Data plane**: Executed in hardware; extremely fast (on the order of nanoseconds).
- **Control plane**: Software-driven path computation; comparatively slower.

### Forwarding Table

- A **mapping used by routers** when sending packets (**destination → next-hop/output port**).
- Cloud **route tables** follow this exact principle.

> In other words, it’s the table that decides which gateway to use for a given IP prefix.
> 

### Two approaches to the control plane

### Traditional (Per-Router Control)

- Each router **runs routing algorithms locally** to compute its forwarding table.
- Routers **exchange path information** (e.g., OSPF, BGP).

> A distributed model where “each node computes for itself.”
> 

### SDN (Software-Defined Networking)

- A **central controller** computes routes; routers simply **enforce** the instructions.
- **Separates forwarding from control**, enabling efficient management.

> SDN centralizes network control in software,
> 
> 
> a foundational approach in modern cloud infrastructure.
> 

### Network service model

Examples of services the network layer *could* provide:

| Service type | Description |
| --- | --- |
| **Guaranteed delivery** | Ensure packets always reach the destination. |
| **Guaranteed delay** | Ensure delivery within a specified bound (e.g., ≤ 100 ms). |
| **Ordered delivery** | Preserve the sending order at the receiver. |
| **Minimum bandwidth guarantee** | Reserve a rate to provide stable throughput. |
| **Security service** | Confidentiality via source encryption and destination decryption. |

However, **the Internet’s IP layer does not provide these guarantees**.

### What the Internet’s network layer actually provides

- IP offers only a **best-effort service**.
- Therefore, the following are **not guaranteed**:
    - Delivery to the destination
    - Preservation of packet order
    - Any upper bound on delay
    - Stable or minimum bandwidth

> Although IP is merely best effort,
> 
> 
> its **simplicity and scalability** underpin most networks in operation today.
> 

---

## 5.2 Router

### Overview

- A **router** is a core device at the network layer that **forwards IP packets from one link to the next**.
- Routers sit at the heart of the **data plane**, where actual **forwarding is executed**.

> A router functions as a high-speed intersection through which packets pass.
> 

### Key Components of a Router

| Component | Role |
| --- | --- |
| **Input Port** | Receives packets, inspects headers, looks up the forwarding table, and performs queuing |
| **Switching Fabric** | The internal interconnect that physically moves packets from input ports to output ports |
| **Output Port** | Performs packet scheduling and queuing, then hands packets to the link layer |
| **Routing Processor** | Manages routing tables and runs the control plane (including OSPF, BGP, and SDN control) |

### Input Port

- The router’s **physical ingress interface**.
- Main functions:
    - **Header inspection:** extract the destination address from the IP header
    - **Forwarding table lookup:** determine the **output port** based on the destination
    - **Queuing:** place packets in an input queue when the switching fabric is not immediately available
- Some high-speed routers use **parallel forwarding-table caching (fast path)** at the input port.

### Switching Fabric

- The router’s **internal data path/backplane**.
- Provides the actual transmission path **from input ports to output ports**.
- Switching fabric performance determines the router’s **throughput**.

> High-speed networks employ parallel switching fabrics to minimize bottlenecks.
> 

### Output Port

- **Receives packets from the switching fabric and hands them to the link layer**.
- Main functions:
    - **Buffering:** temporarily stores packets under congestion
    - **Scheduling:** decides the order in which packets are transmitted
    - **Link-layer processing:** adds MAC headers and transmits

### Queuing and Buffering

- Can occur at **both input and output ports**.
- **Input queue:** used when the switching fabric is busy
    - Susceptible to **Head-of-Line (HOL) blocking**, where the first packet stalls those behind it
- **Output queue:** used when multiple inputs contend for the same output
    - **Packet drops** occur when buffers overflow
    - TCP interprets drops as congestion and triggers **congestion control**

> Queue buildup and buffer overflow are major causes of network delay and loss.
> 

### Packet Scheduling

| Algorithm | Description |
| --- | --- |
| **FIFO (First In, First Out)** | Transmit packets in order of arrival |
| **Priority Queuing** | Serve higher-priority traffic first (e.g., voice) |
| **Round Robin / Fair Queuing** | Cycle across multiple queues to share bandwidth fairly |
| **Weighted Fair Queuing (WFQ)** | Assign weights to flows to refine fairness and service differentiation |

---

## 5.3 Internet Protocol (IP)

### Overview

- **IP (Internet Protocol)** is the core protocol of the network layer that defines the **addressing and forwarding rules** for delivering data **from a source host to a destination host**.
- IP follows a **best-effort delivery** model and **does not guarantee reliability, ordering, or delay bounds**.
    
    (→ The transport layer’s TCP compensates for reliability.)
    

### IPv4 Datagram Format

| Field | Description |
| --- | --- |
| **Version (4 bits)** | Specifies the IP version (4 for IPv4). |
| **Header Length (4 bits)** | Actual header length (variable when options are present). |
| **Type of Service (TOS)** | Priority/service differentiation (used for QoS). |
| **Total Length (16 bits)** | Total datagram length (up to 65,535 bytes). |
| **Identifier / Flags / Fragment Offset** | Fields related to fragmentation. |
| **TTL (Time To Live)** | Hop limit; decremented at each router, dropped at zero. |
| **Protocol** | Upper-layer protocol identifier (e.g., TCP=6, UDP=17). |
| **Header Checksum** | Header error detection (recomputed by each router). |
| **Source IP / Destination IP** | Source and destination addresses. |
| **Options** | Extension mechanisms (rarely used). |
| **Data (Payload)** | Upper-layer segment (e.g., transport-layer data). |

### IPv4 Addressing and Subnets

- **IP addresses are assigned to interfaces, not to hosts.**
    
    → A single device may attach to multiple networks (e.g., routers).
    
- **Subnet:** a network region where nodes can communicate **without a router**.
    - Example: `192.168.0.0/24` → hosts communicate locally without routing.
- **CIDR notation (a.b.c.d/x):**
    - `/x` denotes the number of network bits.
    - Enables more flexible partitioning of address space.

> Practical example: In a cloud VPC, create 10.0.0.0/16 and split into /24 subnets.
> 

### DHCP (Dynamic Host Configuration Protocol)

- Protocol by which a host **automatically acquires an IP address**.
- Also supplies auxiliary parameters (subnet mask, default gateway, DNS servers, etc.).
- **Four-step process:**

| Step | Description |
| --- | --- |
| ① **DHCP Discover** | Client → broadcast to the network (255.255.255.255). |
| ② **DHCP Offer** | Server → proposes an available IP address. |
| ③ **DHCP Request** | Client → selects a specific server/offer. |
| ④ **DHCP ACK** | Server → confirms the lease and configuration. |

> Pros: Plug-and-play auto-configuration.
> 
> 
> Cons: Moving to a new subnet changes the IP address → existing TCP connections break.
> 

### NAT (Network Address Translation)

- Allows multiple hosts in a **private network** to communicate externally using **a single public IP**.
    - Private ranges: `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`
    - Externally, the router represents them with **one public IP** (e.g., `138.76.29.7`).
- Advantages:
    - Conserves public IP space.
    - Shields the internal network (harder for unsolicited inbound access).
- Disadvantages:
    - **Inbound access from the Internet is restricted** → inconvenient for servers/P2P.
    - Workarounds: **NAT traversal** techniques (STUN, TURN, UPnP).

### IPv6 (Internet Protocol Version 6)

### Rationale

- IPv4 address exhaustion → IPv6 introduces a **128-bit address space**.
- Coexists with IPv4 via **dual-stack** during gradual migration.

### Key Changes (at a glance)

| Feature | IPv4 | IPv6 |
| --- | --- | --- |
| Address length | 32 bits | 128 bits |
| Address notation | `192.168.0.1` | `2001:db8::1` |
| Checksum | Present | Removed (simplified header) |
| Fragmentation | By all routers | Only at endpoints (source/destination) |
| Security | Optional (IPsec) | **Integrated** by default |
| QoS | Limited | Explicit support via **Flow Label** |

> IPv6 targets vast addressing, streamlined routing, and security-by-default.
> 

### IPv4 → IPv6 Transition Mechanisms

- **Tunneling:** Encapsulate IPv6 packets inside IPv4 packets to traverse IPv4 networks.
    
    → Enables IPv6 communication over existing IPv4 infrastructure.
    
- **Dual Stack:** Run both IPv4 and IPv6 concurrently.

> In practice, most systems operate in dual-stack mode,
> 
> 
> and IPv6 is expanding incrementally (fully supported on AWS, Google Cloud, etc.).
> 

---

## 5.4 Software-Defined Networking (SDN)

### Overview

- **SDN (Software-Defined Networking)** separates the network’s **control plane** from the **data plane**.
- In traditional routers, packet forwarding and path computation (routing) are both performed on the device; in SDN, **the controller handles control**, while **simple switches handle forwarding**.
- This enables **software-driven control** of networks, allowing **automation, scalability, and policy-based control** in cloud and data center environments.

> Traditional networks: “each router decides for itself.”
> 
> 
> SDN: “the controller dictates, and switches follow.”
> 

### Limitations of Traditional Networks

1. **Hardware-centric** — device-by-device manual configuration; poor scalability
2. **Difficult policy expression** — limited ability to enforce fine-grained allow/deny rules
3. **Lack of automation** — limited real-time response to failures or traffic shifts

→ SDN emerged to address these limitations.

### Core SDN Architecture

| Component | Role |
| --- | --- |
| **Data Plane** | Switches/routers **forward packets** based on **flow tables**. |
| **Control Plane** | A centralized **SDN controller** maintains global state and computes/distributes flow rules. |

> The controller acts as the “brain,” and the switches are the “hands.”
> 
> 
> (e.g., OpenFlow-capable switches with an ONOS controller)
> 

### Flow-Based Forwarding (Match + Action)

- Traditional routers forward primarily on destination IP; SDN switches can define behavior using **multiple header fields** (IP, MAC, ports, protocol, etc.).
- Rules are installed in flow tables as “if a packet matches these conditions, perform these actions.”

| Element | Description |
| --- | --- |
| **Match** | Packet header predicates (e.g., srcIP, dstPort, MAC, TCP flags). |
| **Action** | Operation when matched (forward, modify, drop, punt, etc.). |
| **Counter** | Statistics for matched packets/bytes/flows. |

> “Match + Action” is SDN’s basic execution unit, and rules are delivered from the controller to switches via the OpenFlow protocol.
> 

### OpenFlow Protocol

- A **standard protocol** for communication between the SDN controller and switches.
- Uses **TCP port 6653**.
- The controller **remotely programs** a switch’s flow tables via OpenFlow.

| Direction | Example Command | Description |
| --- | --- | --- |
| Controller → Switch | **Modify-State** | Add/modify/delete flow-table entries. |
| Controller → Switch | **Send-Packet** | Transmit a specific packet out a given port. |
| Switch → Controller | **Packet-In** | Send unmatched packets to the controller. |
| Switch → Controller | **Port Status** | Report link/port state changes. |

> OpenFlow enables the controller to effectively program switch behavior.
> 

### Example: Control-Plane Operation

1. A switch sends an **unmatched packet** to the controller (**Packet-In**).
2. The controller computes a path according to policy logic.
3. The controller issues a **flow-install (Modify-State)** command.
4. The switch stores the new rule; subsequent matching packets are handled locally at line rate.

> Once learned, subsequent traffic is forwarded at high speed without controller intervention.
> 

### Advantages of SDN

| Item | Description |
| --- | --- |
| **Flexibility** | Update network policies as code, instantly. |
| **Automation** | Compute automatic failover/alternate paths upon faults. |
| **Centralized management** | Operate all devices via a single controller. |
| **Policy-based control** | Apply granular QoS, security, and traffic engineering. |
| **Scalability** | Suited to cloud/data center scale. |

### Representative SDN Controllers

| Controller | Characteristics |
| --- | --- |
| **ONOS (Open Network Operating System)** | “Intent-based” model — declare “connect A to B,” and it computes paths automatically. |
| **OpenDaylight (ODL)** | Open-source, broadly standardized controller; supports multiple southbound protocols (OpenFlow, NETCONF, etc.). |
| **Ryu / Floodlight** | Lightweight, research/education-friendly controllers with Python-based development. |

### Related Technologies

| Technology | Description |
| --- | --- |
| **NFV (Network Function Virtualization)** | Runs functions like firewalls/load balancers as software on virtualized infrastructure. |
| **Intent-based Networking (IBN)** | Operators declare **what** they want; the SDN controller computes **how** to realize it. |

### Key Takeaways

| Item | Summary |
| --- | --- |
| **Core concept** | Separation of the control and data planes. |
| **Central control** | SDN controller computes and distributes flow tables. |
| **Standard protocol** | OpenFlow (TCP 6653). |
| **Execution model** | Match + Action (flow-based forwarding). |
| **Primary benefits** | Automation, flexibility, and policy-based control. |
| **Extensions** | NFV and Intent-based Networking. |
| **Representative controllers** | ONOS, OpenDaylight, Ryu. |

> SDN treats the network as code: instead of per-box configuration, you define and control the network via software logic.
> 
> 
> It is a foundational architecture for modern cloud and data center infrastructures.
> 

---

## 5.5 Middlebox

### Core Concept

- A **middlebox** is a device that, **unlike a router that merely forwards packets**, **interprets traffic and performs control, transformation, and security processing** between the source and destination.
- In short, the key idea is **“do not just forward packets—process them.”**

> Examples: NAT, firewalls, load balancers, proxies.
> 

### Primary Roles and Examples

| Type | Core Role | Representative Devices |
| --- | --- | --- |
| **Address Translation (NAT)** | Translate private IPs to a public IP to enable external communication | NAT routers, home gateways |
| **Security Control (Firewall)** | Inspect and allow/deny packets to protect the network | Firewalls, IDS/IPS |
| **Traffic Distribution (Load Balancing)** | Distribute requests across multiple servers to improve performance | L4/L7 load balancers |
| **Caching/Proxy** | Cache content, relay traffic, and filter requests | Proxy servers, CDN edges |

### Operating Principles (Summary)

- **NAT:** Translate internal private IPs ↔ external public IPs
    
    → Hides internal addresses and conserves public IP space.
    
- **Firewall:** Allow/deny traffic based on IPs, ports, and protocols
    
    → Implemented as “**security groups**” in cloud environments.
    
- **Load Balancer:** Distribute traffic across multiple servers
    
    → Can operate at DNS level, L4 (port-based), or L7 (HTTP-header-based).
    
- **Proxy:** Relay requests on behalf of clients to perform caching, security, and logging.

### Relationship to the Network Layer

- Middleboxes often examine **multiple layers (IP, TCP/UDP, HTTP, etc.)** simultaneously.
- They therefore operate **across OSI layer boundaries**:
    - NAT → modifies IP and ports (L3–L4)
    - Firewall → may inspect HTTP headers (L7)
    - Load balancer → distributes traffic (L4/L7)

> “Routers provide the path; middleboxes define the rules of the path.”
> 

### Summary

- **Middleboxes = the network’s traffic managers**
    
    → They monitor, transform, and control flows.
    
- Three must-know functions in practice:
    1. **NAT:** Connects private networks to the outside world
    2. **Firewall:** Controls inbound/outbound traffic
    3. **Load Balancer:** Distributes server load
- In cloud/DevOps environments, these functions are increasingly delivered as **software-defined middleboxes (often SDN-based)** rather than fixed hardware.

> Bottom line:
> 
> 
> If routers “guide the path,”
> 
> middleboxes **control who can traverse that path**.
> 
> What matters for developers is understanding how these devices affect flow behavior and connectivity architecture.
> 

---

## 5.6 Routing Algorithms

### Core Concept

- **Routing** is the process of finding the **optimal path** for data to travel **from source to destination**.
- Based on routing information, routers build **forwarding tables** to actually deliver packets.
- In the control plane, routing operates in two ways:

| Mode | Description | Example Protocols |
| --- | --- | --- |
| **Distributed (Per-Router)** | Each router computes routes locally and exchanges information with neighbors | OSPF, BGP |
| **Centralized (SDN)** | A centralized controller computes and disseminates end-to-end paths | SDN Controller |

> Routing is about “drawing the map,”
> 
> 
> forwarding is about “walking the path” according to that map.
> 

### Basic Principles of Routing

- A network can be modeled as a **graph** of **nodes (routers)** and **links (connections)**.
- Each link has an associated **cost** (e.g., distance, delay, bandwidth).
- Routers select **minimum-cost (shortest) paths** for packet delivery.

### Two Core Algorithmic Families

### 1) Link-State (LS)

- Every router **shares global topology information** and computes shortest paths locally.
- Uses **Dijkstra’s algorithm** to compute a minimum-cost tree from each node.
- Accurate and fast to converge, but incurs higher overhead in large topologies.

> Representative intra-domain protocol: OSPF.
> 

### 2) Distance-Vector (DV)

- Routers **exchange distance information with neighbors** and learn routes iteratively.
- Based on **Bellman–Ford**:
    
    “Shortest path from me to a destination = (cost to neighbor + neighbor’s distance).”
    
- Simple and fully distributed, but can suffer from **error propagation** and **slow convergence**.

> Representative inter-domain protocol: BGP (path-vector; DV-like).
> 

### LS vs. DV at a Glance

| Aspect | Link-State (LS) | Distance-Vector (DV) |
| --- | --- | --- |
| Information scope | Entire network | Immediate neighbors only |
| Computation | Each router computes global paths | Iterative neighbor exchange |
| Convergence | Fast and accurate | Can be slower |
| Scalability | Less suitable for very large networks | Suited to smaller networks |
| Representative protocols | **OSPF** | **RIP**, **BGP** (*path-vector; DV-like*) |

### The Internet in Practice

- The Internet **combines both approaches**:
    - **Within an AS (intra-domain)**: **OSPF** (link-state)
    - **Across ASes (inter-domain)**: **BGP** (path-vector, conceptually DV-like)
- In other words, **enterprise/internal networks tend to use LS**, while **inter-ISP traffic uses BGP**, which applies DV-style principles at the AS level.

---

## 5.7 Intra-AS Routing on the Internet: OSPF (Open Shortest Path First)

### Overview

- **AS (Autonomous System):** a collection of routers operated by a single administrative entity (e.g., an enterprise or ISP).
- Within the same AS, routes are computed by a single routing protocol → **Intra-AS routing**.
- The representative intra-domain routing protocol is **OSPF (Open Shortest Path First)**.
- **BGP** governs inter-domain traffic; **OSPF** governs intra-domain traffic.

> In short, OSPF is “the mapmaker that finds optimal paths inside our organization’s network.”
> 

### How OSPF Works

- Based on the **Link-State (LS)** algorithm:
    - All routers **share the complete network topology**.
    - Each router computes shortest paths using **Dijkstra’s algorithm**.
- **Flooding:** when a link-state change occurs, information is propagated to all routers in the AS.
- Runs directly over IP and uses **protocol number 89**.

> OSPF operates directly over IP—not on top of TCP or UDP.
> 

### Link Cost

- Path selection is determined by link cost.
- Administrators can tune cost metrics to shape traffic.

| Criterion | Description |
| --- | --- |
| **Hop count** | Prefer paths with the fewest hops. |
| **Bandwidth-based** | Prefer links with higher bandwidth. |
| **Policy-based** | Prefer or avoid certain links per policy. |

### Key Features

| Feature | Description |
| --- | --- |
| **Link-state routing** | Share full topology; each router computes its own shortest paths. |
| **Security** | Authentication between OSPF routers for trust and integrity. |
| **ECMP (Equal-Cost Multipath)** | Use multiple equal-cost paths in parallel for load sharing. |
| **Hierarchical areas** | Partition large networks into areas (with **Area 0** as the backbone). |

> The area hierarchy reduces routing overhead and improves scalability in large deployments.
> 

---

## 5.8 Inter-ISP Routing: BGP (Border Gateway Protocol)

### Core Overview

- The Internet consists of numerous **ASes (Autonomous Systems)**—each an **independently administered network domain** (e.g., an enterprise, ISP, or institution).
- Within an AS, routers communicate using an **interior routing protocol** such as **OSPF**;
    
    **between ASes**, routes are exchanged via **BGP (Border Gateway Protocol)**.
    
- **BGP is the global standard routing protocol** that interconnects the worldwide Internet.

> BGP is the central nervous system linking hundreds of thousands of networks across the globe.
> 

### Roles of BGP

1. **Route Advertisement**
    - Each AS announces the **prefixes** (address blocks) it originates.
    - Example: “I originate the 203.0.113.0/24 block.”
2. **Path Selection**
    - When multiple routes exist, BGP selects the most suitable path based on **policy and path attributes**.

> BGP prefers policy-compliant paths, not merely the “fastest” ones.
> 

### BGP Connectivity Model

| Component | Role |
| --- | --- |
| **Gateway Router** | Sits at the AS boundary and connects to external ASes. |
| **Internal Router** | Forwards traffic within the same AS. |
| **eBGP (External BGP)** | Sessions between **different** ASes. |
| **iBGP (Internal BGP)** | Sessions **within** the same AS. |

> BGP runs over TCP port 179, maintaining persistent sessions atop TCP.
> 

### Key BGP Path Attributes

| Attribute | Meaning |
| --- | --- |
| **AS-PATH** | Sequence of ASes traversed by the route (prevents loops; influences selection). |
| **NEXT-HOP** | IP of the next-hop router toward the advertising AS. |
| **LOCAL PREF** | Intra-AS preference; **higher is preferred**. |
| **MED** | A hint to external neighbors indicating preferred entry points. |

> BGP chooses routes using AS-PATH and policy values (e.g., LocalPref) rather than pure distance metrics.
> 

### Core Selection Idea: **Hot-Potato Routing**

- Among multiple valid exits, choose the gateway with the **lowest internal cost** and hand off traffic to another AS **as early as possible**.

> “Don’t hold the packet—forward it through the closest exit.”
> 

### Policy-Based Routing

- BGP decisions reflect **business relationships and policies**, not just shortest paths.

| Relationship | Description |
| --- | --- |
| **Customer** | Purchases transit from a provider ISP. |
| **Provider** | Sells Internet connectivity (transit). |
| **Peer** | Lateral relationship; exchange **only customer** traffic. |

> ISPs generally avoid carrying third-party transit that yields no revenue.
> 
> 
> In effect, BGP operational behavior is driven heavily by **business logic**.
> 

### IP Anycast

- Assign the **same IP address** to multiple servers in different regions,
    
    so users are routed to the **topologically closest** instance (often the shortest AS-PATH).
    
- Common use cases:
    - DNS root servers
    - Global services such as Cloudflare and Google DNS

> Anycast = “one IP, many actual servers,” leveraging BGP’s path selection.
> 

### OSPF vs. BGP at a Glance

| Aspect | **OSPF (Intra-AS)** | **BGP (Inter-AS)** |
| --- | --- | --- |
| Purpose | Optimize routing **within** an organization’s network | Connect networks **across** the global Internet |
| Criterion | Cost-based (speed, distance) | Policy-based (AS relationships, economics) |
| Model | Link-state | Distance-vector–like + policy (path-vector) |
| Typical Scope | Enterprises, institutions | ISPs, global-scale traffic |
| Notable Traits | Fast convergence, relative simplicity | Policy-driven, highly scalable |

---

## 5.9 Internet Control Message Protocol (ICMP)

### Overview

- **ICMP** is a protocol at the IP layer responsible for **exchanging error and control messages between hosts and routers**.
- It is not used for ordinary data transport; instead, it is used for **network diagnostics (Ping, Traceroute)** and **error reporting**.
- ICMP messages are carried **inside IP datagrams (as the IP payload)** and use **IP protocol number 1**.

> ICMP is the “status reporting system” for IP—a signaling mechanism to assess the network’s health.
> 

### Message Structure

- Every ICMP message includes the following fields:

| Field | Description |
| --- | --- |
| **Type** | Message category (e.g., request, reply, error). |
| **Code** | Subtype (e.g., network unreachable, port unreachable). |
| **Checksum** | Error detection. |
| **Data** | Includes the offending IP header plus part of the original payload. |

> This layout lets the sender identify exactly which packet caused the issue.
> 

### Common ICMP Messages

| Type | Code | Meaning |
| --- | --- | --- |
| **0** | 0 | Echo Reply |
| **3** | Var. | Destination Unreachable |
| **8** | 0 | Echo Request |
| **11** | 0 | Time Exceeded (TTL expired) |
| **12** | 0 | Parameter Problem (invalid header) |

### Ping (Liveness Check)

- **Ping** is the most common use of ICMP.
1. The sender transmits an **Echo Request (Type 8)**.
2. The receiver responds with an **Echo Reply (Type 0)**.
3. The sender measures the time to receive the reply and reports the **RTT (Round-Trip Time)**.

> Ping = “Connectivity and latency check using ICMP echo request/reply.”
> 

### Traceroute (Path Discovery)

- **Traceroute** reveals the sequence of routers a packet traverses.

**How it works**

1. Send packets with **TTL = 1**, incrementing TTL step by step (commonly using UDP segments).
2. Each router where TTL hits zero returns **ICMP Time Exceeded (Type 11)**.
3. The sender records the **source IP** of each ICMP response to map the path.
4. At the final destination, the probe elicits **ICMP Destination Unreachable (Type 3, Code 3)** to terminate the trace.

> Traceroute = “Route discovery via TTL-expired ICMP messages.”
> 

### Summary

| Item | Details |
| --- | --- |
| **Protocol Name** | ICMP (Internet Control Message Protocol) |
| **Layer Position** | Immediately above the IP layer |
| **Primary Functions** | Error reporting, path discovery, reachability checks |
| **Representative Messages** | Echo Request/Reply, Destination Unreachable, Time Exceeded |
| **IP Protocol Number** | 1 |
| **Key Uses** | Ping, Traceroute |

> ICMP is not a protocol for sending application data—
> 
> 
> it’s the protocol that tells you whether **data is being delivered correctly**.
> 
> In essence, it serves as the **diagnostic and error-reporting nervous system** of IP networks.
> 

---

## 5.10 Network Management with SNMP and NETCONF/YANG

### Overview

- **Network management** comprises **monitoring, configuration, analysis, and control** activities to maintain **performance, reliability, and QoS**.
- Administrators observe device status (routers, switches, servers), perform remote control, and prevent incidents.
- Modern network management emphasizes **automation** and **centralized control**.

> Goal of network management: operate services stably and manage them efficiently with minimal human effort.
> 

### Components of Network Management

| Component | Role |
| --- | --- |
| **Manager (NMS)** | Central control system; collects/analyzes state and issues configuration commands. |
| **Agent** | Runs on each device; reports status and executes commands. |
| **Management data (MIB, YANG)** | Data models that express device state and configuration. |
| **Management protocols (SNMP, NETCONF)** | Communication between manager and devices. |

> In simple terms, the manager calls the devices’ “APIs” to query state and apply control.
> 

### Evolution of Network Management

| Generation | Method | Characteristics |
| --- | --- | --- |
| **1st: CLI (Command Line)** | Manual commands via SSH/Telnet | Simple but not automatable. |
| **2nd: SNMP (Simple Network Management Protocol)** | Query/modify a device’s **MIB database** | Introduced a standardized management framework. |
| **3rd: NETCONF + YANG** | Configuration automation using XML/JSON data models | Suited for SDN/cloud environments. |

### SNMP (Simple Network Management Protocol)

- **SNMP** is the most widely used network management protocol.
- A manager requests status (`Get`), modifies settings (`Set`), and agents send asynchronous notifications (`Trap`).
- Operates over **UDP**—lightweight and simple, but with lower reliability.

| Operation | Description |
| --- | --- |
| **Get / Set** | Manager reads or modifies MIB data on a device. |
| **Trap** | Device immediately notifies the manager upon faults/events. |

> SNMP works via polling for state and traps for events.
> 

### MIB (Management Information Base)

- The **database schema** for all information managed via SNMP.
- Defined as a **tree**; each node has a unique **OID (Object Identifier)**.
- Examples:
    - System name (`sysName`)
    - Interface status (`ifStatus`)
    - Traffic counters (`ifInOctets`, `ifOutOctets`)

> MIB is the standardized set of state variables inside the device—SNMP is the interface to read and write them.
> 

### NETCONF (Network Configuration Protocol)

- **NETCONF** was introduced to overcome SNMP’s limitations in configuration.
- Exchanges data in **XML** or **JSON** and performs operations over **secure channels (TLS/SSH)**.
- Communication follows an **RPC (Remote Procedure Call)** model.

| RPC | Description |
| --- | --- |
| `<get>` | Retrieve device state or statistics. |
| `<edit-config>` | Modify configuration. |
| `<copy-config>` | Copy configuration data stores. |
| `<delete-config>` | Delete configuration data stores. |

> NETCONF standardizes safe, transactional configuration changes, not just status retrieval—forming the basis for automated management in SDN environments.
> 

### YANG (Yet Another Next Generation)

- **YANG** is the **data modeling language** used with NETCONF.
- Defines device configuration, state, and statistics in a **tree structure**.
- Serialized as XML or JSON and used together with NETCONF.

**Example**

```
module example-interface {
  container interface {
    leaf name { type string; }
    leaf speed { type uint32; }
    leaf status { type boolean; }
  }
}
```

> YANG is a common language to express device state/config—allowing vendor-agnostic data handling.
> 

### SNMP vs. NETCONF/YANG

| Item | SNMP | NETCONF/YANG |
| --- | --- | --- |
| **Data model** | Simple key–value (MIB/OIDs) | Structured XML/JSON (YANG models) |
| **Transport** | UDP (unreliable) | TCP with SSH/TLS (reliable, secure) |
| **Primary focus** | Status monitoring | Configuration/control/automation |
| **Extensibility** | Limited | High (well-suited to SDN/cloud) |

### Key Takeaways

| Item | Summary |
| --- | --- |
| **SNMP** | UDP-based, simple management; centered on querying MIB data. |
| **MIB** | Standardized device state database for SNMP. |
| **NETCONF** | XML/JSON-based configuration/state protocol (RPC over secure channels). |
| **YANG** | Data modeling language for NETCONF. |
| **Trend** | CLI → SNMP/MIB → NETCONF/YANG (toward automation). |

> In SDN and cloud infrastructures, NETCONF/YANG is a core technology for programmable networks, enabling operators to manage the network as code.
>
