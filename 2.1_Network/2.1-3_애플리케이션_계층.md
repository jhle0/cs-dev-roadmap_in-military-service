# 2.1-3 애플리케이션 계층 (Application Layer)

> Active recall
> 
> - 클라이언트–서버 vs P2P 차이, 장단점, 사례를 한 줄로 설명할 수 있다.
> - 소켓의 역할(앱↔트랜스포트 인터페이스)과 TCP/UDP 차이를 말할 수 있다.
> - HTTP의 특징(Stateless, 전송 계층), HTTP/1.1·2·3의 차이를 설명할 수 있다.
> - HTTP 요청/응답 구조, **메서드/멱등성**, 대표 **상태코드**, **쿠키/세션/토큰**, **캐시 헤더**를 말할 수 있다.
> - 이메일의 **SMTP/IMAP/POP3** 역할과 **SPF/DKIM/DMARC/STARTTLS**를 설명할 수 있다.
> - DNS의 **계층 구조/질의 흐름**, **레코드(A/AAAA/CNAME/NS/MX/TXT)**, **UDP/TCP/EDNS0**, **DNSSEC/DoH/DoT**를 말할 수 있다.
> - P2P(BitTorrent)의 **청크/rarest-first/tit-for-tat**, **DHT**, **NAT 우회(STUN/TURN/ICE)**를 설명할 수 있다.
> - 소켓 서버의 **블로킹/논블로킹**, **select/epoll**, **Nagle/Delayed ACK**, **TIME_WAIT**를 설명할 수 있다.
> - 스트리밍의 **ABR(DASH/HLS)**와 **CDN(캐시 키/무효화/근접 라우팅)**를 말할 수 있다.

---

## 3.1 네트워크 애플리케이션 원리

### 애플리케이션 개발자의 역할

- **네트워크 코어(라우터/스위치)는 단순 전달만** 한다
    
    → 패킷 손실·지연·혼잡 같은 상황에서 **신뢰성, 성능, 보안은 개발자가 직접 챙겨야 함**
    
- 애플리케이션 레벨에서 다루는 것들:
    - **타임아웃**: 응답이 없으면 일정 시간 후 실패 처리
    - **재시도(지수 백오프)**: 실패 시 점점 간격을 늘려 재시도
    - **서킷 브레이커**: 서버가 계속 죽어있으면 요청 차단 후 일정 간격만 재시도
    - **캐싱**: 반복 요청 시 속도 개선, 서버 부하 완화
    - **TLS/HTTPS**: 데이터 암호화, 무결성·기밀성 보장
    - **인증/인가(OAuth, JWT)**: 사용자가 누구인지, 권한이 맞는지 확인

### 애플리케이션 구조

### 1) 클라이언트–서버

- 항상 동작하는 **서버(고정 IP/도메인)**, 클라↔서버 통신(클라↔클라 X).
- **장점**: 중앙 통제·관리가 쉬움, 컴플라이언스 용이
- **단점**: 서버가 병목/비용 부담
- **사례**: 웹 서비스, 쇼핑몰, REST/GraphQL API

### 2) P2P

- 중앙 서버 의존 최소화, 피어 간 직접 통신
- **자가 확장성(Self-scalability)**: 사용자가 늘수록 업로드 자원도 함께 늘어나 전체 처리 능력 증가
    
    → “파일을 다른 피어들에게 분배함으로써 서비스 능력이 추가된다” = 피어가 곧 작은 서버 역할
    
- **과제(Challenges)**: NAT/방화벽 문제, 보안/프라이버시, 피어 이탈·프리라이더
- **사례**: BitTorrent, WebRTC 파일/화상, 블록체인

### 프로세스 & 소켓

- **프로세스(Process)**: 실행 중인 프로그램 네트워크 통신의 단위
    - **클라이언트**: 통신 시작 (연결 요청)
    - **서버**: 대기하며 클라이언트 요청 수락
- **소켓(Socket)**: 애플리케이션 ↔ 트랜스포트 계층 인터페이스 “프로세스의 네트워크 문”
    - **주소 지정**: `(IP 주소, Port 번호)` 조합으로 특정 프로세스 식별
    - 서버: 고정 포트 (예: 80, 443, 25, 53)
    - 클라이언트: OS가 임시 포트(에페멀 포트) 할당
    - **TCP 소켓**: 연결 지향, 바이트 스트림 (경계 없음)
    - **UDP 소켓**: 비연결, 메시지 단위 유지

### 애플리케이션이 이용 가능한 트랜스포트 서비스 (Transport Services)

애플리케이션은 **소켓**을 통해 트랜스포트 계층을 이용한다

트랜스포트 프로토콜이 제공할 수 있는 서비스는 크게 4가지

1. **신뢰적 데이터 전송 (Reliable Data Transfer)**
    - 데이터가 손실 없이, 순서대로 도착하는 보장을 제공
    - 예: TCP는 제공, UDP는 제공하지 않음
    - 손실 허용 애플리케이션: 실시간 비디오/오디오(약간의 손실은 괜찮음)
2. **처리율 (Throughput)**
    - 특정 속도(bps)를 보장할 수 있는지 여부
    - **대역폭 민감 애플리케이션**: 멀티미디어, 실시간 음성 통화(너무 낮으면 불가능)
    - **탄력적 애플리케이션(elastic)**: 이메일, 파일 전송(속도 낮아도 결국 도착하면 됨)
3. **시간 (Timing)**
    - 일정 시간 안에 데이터 도착 보장 (예: 100ms 내 전달)
    - 실시간 게임, 화상 회의 같은 애플리케이션에 중요
4. **보안 (Security)**
    - 송신 측에서 데이터 암호화, 수신 측에서 해독
    - TCP 자체는 보안을 제공하지 않음 → TLS로 강화

### 인터넷 전송 프로토콜이 실제 제공하는 서비스

1. **TCP (Transmission Control Protocol)**
    - **연결 지향(Connection-oriented)**: 통신 전에 핸드셰이크로 연결 수립 → 준비 완료 후 데이터 전송
    - **신뢰적 데이터 전송**: 바이트 스트림이 손실·중복 없이, 순서대로 도착
    - **혼잡 제어**: 네트워크 혼잡 시 송신 속도 자동 조절
2. **UDP (User Datagram Protocol)**
    - **비연결형(Connectionless)**: 핸드셰이크 없음
    - **비신뢰적 전송**: 손실/순서 보장 없음
    - **혼잡 제어 없음**: 송신 속도를 네트워크 상황과 무관하게 그대로 보냄
        
        → 지연은 적지만 혼잡 시 성능이 오히려 더 떨어질 수 있음
        

**→ TCP와 UDP가 제공하지 않는 것**

- 처리율(Throughput) 보장, 시간(Timing) 보장
- 따라서 실시간 앱은 자체적으로 지연을 견딜 수 있게 설계해야 한다

### 애플리케이션 계층 프로토콜

- **정의**: 서로 다른 종단 시스템의 애플리케이션 프로세스가 메시지를 주고받는 규칙
    - 메시지 타입 (요청/응답 등)
    - 문법(syntax): 필드 구조와 표현 방식
    - 의미(semantics): 각 필드의 의미
    - 절차(rule): 언제 어떤 메시지를 보내고 응답하는지
- **공개 표준**: HTTP, SMTP, DNS → RFC에 정의 → 누구나 구현 가능
- **독점 프로토콜**: Skype, Zoom 등 일부 기업 전용 → 공개 X
