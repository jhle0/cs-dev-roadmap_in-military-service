# 2.1-3 애플리케이션 계층 (Application Layer)

> Active recall
> 
> - 클라이언트–서버 구조란?
> - P2P 구조란?
> - 소켓이란?
> - TCP와 UDP의 가장 큰 차이는?
> - 애플리케이션에서 타임아웃/재시도가 필요한 이유는?
> - HTTP란?
> - HTTP가 Stateless라는 의미는?
> - HTTP/1.1의 지속 연결(Persistent Connection)이 중요한 이유는?
> - 쿠키의 목적은?
> - 웹 캐시(프록시)의 목적은?
> - SMTP의 역할은?
> - DNS의 핵심 역할은?
> - 클라이언트–서버 대비 P2P의 장점은?
> - DASH(적응형 스트리밍)의 핵심 아이디어는?
> - CDN의 기본 목적은?
> - 엔터 딥(Enter Deep) vs 브링 홈(Bring Home)의 차이는?

---

## 3.1 네트워크 애플리케이션 원리

### 애플리케이션 개발자의 역할

- **네트워크 코어(라우터/스위치)는 단순 전달만** 한다
    
    → 패킷 손실·지연·혼잡 같은 상황에서 **신뢰성, 성능, 보안은 개발자가 직접 챙겨야 함**
    
- 애플리케이션 레벨에서 다루는 것들:
    - **타임아웃**: 응답이 없으면 일정 시간 후 실패 처리
    - **재시도(지수 백오프)**: 실패 시 점점 간격을 늘려 재시도
    - **서킷 브레이커**: 서버가 계속 죽어있으면 요청 차단 후 일정 간격만 재시도
    - **캐싱**: 반복 요청 시 속도 개선, 서버 부하 완화
    - **TLS/HTTPS**: 데이터 암호화, 무결성·기밀성 보장
    - **인증/인가(OAuth, JWT)**: 사용자가 누구인지, 권한이 맞는지 확인

### 애플리케이션 구조

### 1) 클라이언트–서버

- 항상 동작하는 **서버(고정 IP/도메인)**, 클라↔서버 통신(클라↔클라 X).
- **장점**: 중앙 통제·관리가 쉬움, 컴플라이언스 용이
- **단점**: 서버가 병목/비용 부담
- **사례**: 웹 서비스, 쇼핑몰, REST/GraphQL API

### 2) P2P

- 중앙 서버 의존 최소화, 피어 간 직접 통신
- **자가 확장성(Self-scalability)**: 사용자가 늘수록 업로드 자원도 함께 늘어나 전체 처리 능력 증가
    
    → “파일을 다른 피어들에게 분배함으로써 서비스 능력이 추가된다” = 피어가 곧 작은 서버 역할
    
- **과제(Challenges)**: NAT/방화벽 문제, 보안/프라이버시, 피어 이탈·프리라이더
- **사례**: BitTorrent, WebRTC 파일/화상, 블록체인

### 프로세스 & 소켓

- **프로세스(Process)**: 실행 중인 프로그램 네트워크 통신의 단위
    - **클라이언트**: 통신 시작 (연결 요청)
    - **서버**: 대기하며 클라이언트 요청 수락
- **소켓(Socket)**: 애플리케이션 ↔ 트랜스포트 계층 인터페이스, “프로세스의 네트워크 문”
    - **주소 지정**: `(IP 주소, Port 번호)` 조합으로 특정 프로세스 식별
    - 서버: 고정 포트 (예: 80, 443, 25, 53)
    - 클라이언트: OS가 임시 포트(에페멀 포트) 할당
    - **TCP 소켓**: 연결 지향, 바이트 스트림 (경계 없음)
    - **UDP 소켓**: 비연결, 메시지 단위 유지

### 애플리케이션이 이용 가능한 트랜스포트 서비스 (Transport Services)

애플리케이션은 **소켓**을 통해 트랜스포트 계층을 이용한다

트랜스포트 프로토콜이 제공할 수 있는 서비스는 크게 4가지

1. **신뢰적 데이터 전송 (Reliable Data Transfer)**
    - 데이터가 손실 없이, 순서대로 도착하는 보장을 제공
    - 예: TCP는 제공, UDP는 제공하지 않음
    - 손실 허용 애플리케이션: 실시간 비디오/오디오(약간의 손실은 괜찮음)
2. **처리율 (Throughput)**
    - 특정 속도(bps)를 보장할 수 있는지 여부
    - **대역폭 민감 애플리케이션**: 멀티미디어, 실시간 음성 통화(너무 낮으면 불가능)
    - **탄력적 애플리케이션(elastic)**: 이메일, 파일 전송(속도 낮아도 결국 도착하면 됨)
3. **시간 (Timing)**
    - 일정 시간 안에 데이터 도착 보장 (예: 100ms 내 전달)
    - 실시간 게임, 화상 회의 같은 애플리케이션에 중요
4. **보안 (Security)**
    - 송신 측에서 데이터 암호화, 수신 측에서 해독
    - TCP 자체는 보안을 제공하지 않음 → TLS로 강화

### 인터넷 전송 프로토콜이 실제 제공하는 서비스

1. **TCP (Transmission Control Protocol)**
    - **연결 지향(Connection-oriented)**: 통신 전에 핸드셰이크로 연결 수립 → 준비 완료 후 데이터 전송
    - **신뢰적 데이터 전송**: 바이트 스트림이 손실·중복 없이, 순서대로 도착
    - **혼잡 제어**: 네트워크 혼잡 시 송신 속도 자동 조절
2. **UDP (User Datagram Protocol)**
    - **비연결형(Connectionless)**: 핸드셰이크 없음
    - **비신뢰적 전송**: 손실/순서 보장 없음
    - **혼잡 제어 없음**: 송신 속도를 네트워크 상황과 무관하게 그대로 보냄
        
        → 지연은 적지만 혼잡 시 성능이 오히려 더 떨어질 수 있음
        

**→ TCP와 UDP가 제공하지 않는 것**

- 처리율(Throughput) 보장, 시간(Timing) 보장
- 따라서 실시간 앱은 자체적으로 지연을 견딜 수 있게 설계해야 한다

### 애플리케이션 계층 프로토콜

- **정의**: 서로 다른 종단 시스템의 애플리케이션 프로세스가 메시지를 주고받는 규칙
    - 메시지 타입 (요청/응답 등)
    - 문법(syntax): 필드 구조와 표현 방식
    - 의미(semantics): 각 필드의 의미
    - 절차(rule): 언제 어떤 메시지를 보내고 응답하는지
- **공개 표준**: HTTP, SMTP, DNS → RFC에 정의 → 누구나 구현 가능
- **독점 프로토콜**: Skype, Zoom 등 일부 기업 전용 → 공개 X

---

## 3.2 웹과 HTTP

### HTTP 개요

- **HTTP (HyperText Transfer Protocol)**: 웹의 핵심 애플리케이션 계층 프로토콜
- 정의: 메시지 **형식**과 클라이언트–서버 간 메시지 **교환 절차** 규정 (RFC 1945, 7230, 7540 등)
- **웹 페이지 = 여러 객체(Object)의 집합**
    - 기본 HTML + 이미지, CSS, JS 등
    - 각 객체는 **URL(Uniform Resource Locator)**로 식별
    - URL 구조: `http://www.school.edu/picture.gif`
        - Host: `www.school.edu`
        - Path: `picture.gif`
- **웹 브라우저 = HTTP 클라이언트**, **웹 서버 = HTTP 서버**
    - 클라이언트는 요청 메시지 전송
    - 서버는 응답 메시지 전송

**특징**

- HTTP는 **TCP 기반(기본 포트 80, HTTPS는 443)**
- TCP가 **신뢰성(손실 없는 전송, 순서 보장)**을 제공하므로, HTTP는 이를 신경 쓰지 않고 동작
- **Stateless 프로토콜**: 서버는 클라이언트 상태를 저장하지 않음 (쿠키/세션으로 보완)

### 비지속 연결 vs 지속 연결

**비지속 연결 (HTTP/1.0)**

- 각 요청/응답 쌍마다 별도의 TCP 연결 사용
- 과정: HTML 요청 → 응답 → 연결 종료 → 추가 객체 요청 시 새 연결
- 응답 시간: **2RTT + 전송 시간**
- **단점**
    - 객체마다 새로운 연결 필요 → TCP 버퍼·변수 관리 부담
    - 매번 2RTT 소요

**지속 연결 (HTTP/1.1, 기본)**

- 응답 후에도 TCP 연결 유지
- 이후 객체 요청·응답은 같은 연결로 처리
- **파이프라이닝**: 이전 응답을 기다리지 않고 여러 요청을 연속 전송
- 서버는 일정 시간 유휴 시 연결 종료

### HTTP 메시지 포맷

**요청 메시지**

```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept-language: fr
```

- **요청 라인**: Method(GET, POST, HEAD, PUT, DELETE 등) + URL + HTTP 버전
- **헤더 라인**: Host, Connection, User-agent, Accept-language 등
- **개체 몸체(Entity body)**: 보통 POST 시 사용

**응답 메시지**

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
(data data data...)
```

- **상태 라인**: 버전, 상태 코드, 상태 메시지
- **헤더 라인**: Connection, Date, Server, Last-Modified, Content-Length, Content-Type
- **상태 코드 예시**:
    - 200 OK
    - 301 Moved Permanently
    - 400 Bad Request
    - 404 Not Found
    - 505 HTTP Version Not Supported

### 쿠키 (Cookies)

- HTTP는 Stateless → 서버가 클라이언트 상태를 직접 추적 불가
- **쿠키 = 상태를 유지하는 방법(Staeless 단점 보완)**
- 동작 과정
    1. 서버가 식별번호 생성 후 DB에 기록
    2. 응답 메시지에 `Set-Cookie` 헤더 포함
    3. 브라우저는 쿠키 파일에 저장
    4. 동일 서버 재접속 시 `Cookie: <id>` 헤더 전송 → 서버는 사용자 식별

**활용**: 로그인 세션 유지, 사용자별 맞춤 서비스, 광고 추적

### 웹 캐싱 (Web Caching)

- **웹 캐시/프록시 서버**: 웹 서버를 대신하여 HTTP 요구를 충족시키는 개체
- **동작 과정**
    1. 브라우저가 캐시에 요청
    2. 캐시에 객체 있으면 바로 응답
    3. 없으면 원 서버에 요청 후, 결과를 캐시에 저장하고 클라이언트에 전달
- **이점**
    - 응답 시간 단축 (클라이언트–캐시 간 고속 LAN)
    - 기관 ISP의 외부 트래픽 절감
    - 인터넷 전체 트래픽 감소 → 성능 향상

> 캐시(cache)는 요청과 응답을 모두 하는 **클라이언트**이면서 **서버**이다.
> 
- **조건부 GET(conditional GET)** : 웹 캐시 내부에 있는 복사본이 **새 것이 아닐 수 있다는 문제**를 해결 → 최신성 보장
    - 요청에 `If-Modified-Since` 헤더 포함
    - 서버 객체가 갱신 안 됐으면 `304 Not Modified` 응답

### HTTP/2와 HTTP/3

**HTTP/1.1 문제**

- 하나의 TCP 연결에서 **HOL(Head-of-Line) 블로킹** 발생
    
    → 앞 요청이 늦어지면 뒤 요청도 줄줄이 지연됨
    
- 해결책: 브라우저가 여러 개의 TCP 연결을 병렬로 열어서 요청 처리
    
    → 하지만 연결 관리·리소스 낭비로 **비효율적**
    

**HTTP/2**

- **프레이밍(framing)**: 데이터를 작은 단위(프레임)로 쪼개 여러 요청의 프레임을 **섞어서(interleaving)** 전송, 도착 후 재조립 → HOL 완화
- **바이너리 인코딩**: 텍스트 대신 바이너리 포맷으로 메시지 처리 → 파싱 효율 ↑, 에러 ↓
- **메시지 우선순위화**: 여러 요청 중 중요한 리소스(CSS, JS 등)를 먼저 받도록 우선순위 지정
- **서버 푸시(Server Push)**: 클라이언트가 HTML 요청 시, 서버가 필요한 CSS/JS를 **미리 전송**

**HTTP/3**

- 전송 계층을 TCP에서 → **QUIC(UDP 기반)**으로 변경
- 장점:
    - **0-RTT 연결**: 재연결 시 핸드셰이크 없이 바로 데이터 전송
    - **혼잡 제어 개선**: 네트워크 혼잡을 TCP보다 효율적으로 제어
    - **패킷 손실 회복 빠름**: 스트림 단위 전송 → 하나의 패킷 손실이 전체 연결을 막지 않음
    - **모바일 환경 최적화**: 와이파이 ↔ LTE 전환 시에도 연결 유지 가능

---

## 3.3 전자 메일 (SMTP/IMAP/POP3)

### 구성 요소

- **UA (User Agent)**: 클라이언트 앱/웹메일
- **Mail Server**: 메일박스 저장, 큐 관리
- **전송**: **SMTP** (서버↔서버)

### SMTP (Simple Mail Transfer Protocol)

> 인터넷 전자메일을 위한 주요 애플리케이션 계층 프로토콜
> 
- TCP 사용해 메일 서버 간 송수신한다
- 또한, 지속 연결(persistent connection)을 사용한다
- 주변 정보가 포함된 `헤더(header)`와 `메시지 몸체(body)`로 구성

### 메일 접속 프로토콜( Mail acess protocols)

메일 서버가 로컬 호스트에 있다면, 호스트는 항상 켜져 있어야 한다. 이는 비현실적

- 대신에 늘 켜져있는 공유 메일 서버에 저장된 메일박스로 수신
- 클라이언트의 사용자 에이전트는 수신자의 메일 서버로 직접 대화하지 않는다

SMTP는 `push` 프로토콜인 반면 메시지를 얻는 것은 `pull` 동작이기 때문에 다른 프로토콜을 사용

- `HTTP`
    - 웹 기반 전자메일이나 스마트폰 앱의 경우에 쓰인다.
    - 당연히 메일 서버는 SMTP 인터페이스와 HTTP 인터페이스 둘 다 가지고 있어야 한다.
- `IMAP` : RFC 3501에 정의된 인터넷 메일 접근 프로토콜

---

## 3.4 DNS (Domain Name System)

### 개요

- **역할**: 사람이 읽기 쉬운 **호스트 이름(hostname)** ↔ 라우터가 이해하는 **IP 주소** 변환
- **구조**: 전 세계에 분산된 **계층적 네임 서버 체계** + 애플리케이션 계층 프로토콜(UDP 53)
- **특징**: 빠른 응답을 위해 **UDP** 기반 (필요 시 TCP 사용), **캐싱**으로 지연 최소화

### 주요 서비스

- **호스트 이름 → IP 주소 변환**
- **호스트 에일리어싱(host aliasing)**: 별칭(CNAME) ↔ 정식 이름(canonical hostname)
- **메일 서버 에일리어싱(mail server aliasing)**: MX 레코드로 단순화된 메일 주소 지원
- **부하 분산(load distribution)**: 여러 서버 IP를 순환 응답하여 트래픽 분산

### DNS 서버 계층 구조

1. **루트 서버**: 전 세계 1000개 이상, TLD 서버 주소 제공
2. **TLD 서버**: `.com`, `.org`, `.kr` 등 최상위 도메인 관리
3. **Authoritative 서버**: 도메인 소유 기관이 직접 관리, 해당 도메인에 대한 최종 레코드 보관
4. **로컬 DNS 서버**: ISP/기관 내부에서 운영, 캐싱을 통해 응답 속도 향상

### 동작 원리

1. 애플리케이션이 DNS 클라이언트 호출 → 호스트 이름 질의
2. 로컬 DNS 서버로 요청 전달 → 루트/TLD/Authoritative 순서로 탐색
3. 최종 IP 주소 반환 → 캐싱 저장
- **재귀 질의**: 상위 서버가 하위 서버 대신 질의
- **반복 질의**: 상위 서버가 "다음 서버 주소"만 알려줌
- 실제는 혼합 사용

### 자원 레코드(Resource Records)

형식: `(Name, Value, Type, TTL)`

- **A**: hostname → IPv4 주소
- **AAAA**: hostname → IPv6 주소
- **NS**: 도메인 → 책임 네임 서버
- **CNAME**: 별칭 hostname → 정식 hostname
- **MX**: 메일 서버 주소

### DNS 메시지 구조

- **Header**: 식별자, 플래그(Q/R, Recursion 등), count 필드
- **Question**: 질의 이름, 타입(A, NS, MX 등)
- **Answer**: 질의 결과(레코드들)
- **Authority**: 다른 권한 서버 정보
- **Additional**: 추가 유용 정보 (예: MX 응답 시 해당 서버의 A 레코드)

### 보안 & 취약점

- **DDoS 공격**: 루트/TLD 서버 대상 대역폭 플러딩
- **DNS 캐시 포이즈닝(DNS 중독 공격)**: 가짜 레코드 삽입 → 사용자를 공격자 서버로 유도
- **DNSSEC**: 전자 서명으로 레코드 무결성 보장

---

## 3.5 P2P 파일 분배

> P2P 구조는 항상 켜져있는 인프라스트럭처 서버에 최소한으로 의존하고, **간헐적으로 연결되는 호스트 쌍들(피어, peer)이 서로 직접 통신한다**
> 

### 클라이언트-서버 방식

- 서버가 모든 파일 복사본을 각 클라이언트에게 직접 전송.
- **문제**: 서버 대역폭 한계 때문에, 클라이언트 수(N)가 늘어날수록 서버 부하가 선형적으로 증가 → 확장성 부족.

### P2P 방식

- 피어가 받은 파일 조각을 다시 다른 피어들에게 업로드 가능.
- 즉, 서버 혼자만 전송하지 않고, **모든 피어가 서버 역할**을 조금씩 분담.
- **자가 확장성(Self-scalability)**: 참여 피어가 많아질수록 전체 업로드 용량이 늘어나, 분배 속도도 빨라짐.
- 단점: NAT/방화벽, 보안, 피어의 이탈 등 문제 존재.

### <비트토렌트(BitTorrent)>

### 토렌트(Torrent)

- 특정 파일을 공유하는 **피어들의 집합**을 토렌트라고 부름.
- 파일은 **청크(chunk)** 단위(보통 256KB)로 나눠져 전송.
- 피어는 청크를 받는 동시에 다른 피어에게 업로드하여 분배에 기여.
- 모든 파일을 받은 피어는 떠날 수도 있고, 계속 남아 업로드만 하는 **시더(seeder)**가 될 수도 있음.

### 트래커(Tracker)

- 토렌트 참여 피어를 추적하는 인프라 서버.
- 새로운 피어가 참여하면 트래커가 무작위로 일부 피어들의 IP를 알려줌 → 새 피어가 이들과 연결 시작.
- 시간이 지나며 연결된 이웃 피어 집합은 계속 변동(churn).

### 교환 전략

1. **가장 드문 것 먼저(Rarest First)**
    - 자신이 갖고 있지 않은 청크 중, 이웃들 사이에서 **가장 적게 퍼져 있는 청크**를 우선 요청.
    - 드문 청크를 먼저 퍼뜨려서 전체 네트워크에 골고루 분배되도록 함.
2. **현명한 교역(Tit-for-Tat)**
    - 자신에게 데이터를 가장 빠르게 보내주는 피어에게 우선적으로 업로드.
    - 상호 보상 구조로, 적극적으로 업로드하는 피어가 더 많은 다운로드 기회를 얻음.
    - 4개의 주요 피어에게만 집중적으로 업로드하고, 가끔 무작위로 새로운 피어에게 업로드 기회를 줘서 교역 관계를 확장.

---

## 3.6 비디오 스트리밍 & CDN

### 인터넷 비디오

- 비디오는 초당 24~30 프레임(이미지)의 연속.
- **압축 필수**: 비트 전송률과 화질은 반비례 → 낮은 비트율 = 저화질, 높은 비트율 = 고화질.
- 스트리밍 비트율: 보통 100kbps ~ 수 Mbps, 4K는 10Mbps 이상.
- 안정적 재생을 위해 **네트워크 처리율 ≥ 비디오 전송률** 필요.
- 하나의 영상은 여러 품질 버전으로 압축해 둔다.

### HTTP 스트리밍 & DASH

- 비디오는 HTTP 서버에 파일로 저장됨 → 클라이언트가 **HTTP GET**으로 요청.
- 클라이언트는 받은 데이터를 **버퍼에 저장 → 일정량 쌓이면 재생 시작**.
- 문제: 네트워크 상황과 상관없이 같은 품질의 비디오만 받음.

**DASH (Dynamic Adaptive Streaming over HTTP)**

- 비디오를 **여러 품질 버전**으로 인코딩해 저장.
- 클라이언트는 네트워크 상황에 맞춰 **각 청크(chunk)**를 다른 품질로 선택 요청.
- **매니페스트(manifest) 파일**: 각 버전의 URL 목록 제공.
- 결과: 가용 대역폭이 넉넉하면 고화질, 부족하면 저화질로 자동 전환.

### CDN (Content Delivery Network)

- 단일 데이터센터에서 전송 시 문제:
    1. 거리가 멀면 링크 병목 발생.
    2. 인기 영상은 중복 전송 비용 큼.
    3. 한 곳 장애 시 전체 서비스 중단.

**해결 → CDN**

- 여러 지역에 분산된 서버 클러스터 운영, 콘텐츠 복사본 저장.
- 사용자는 가장 가까운(또는 성능 좋은) CDN 서버에서 콘텐츠 수신.

**서버 배치 전략**

- **Enter Deep**: ISP 접속망까지 서버를 깊게 분산 배치 (Akamai). → 지연↓, 관리비용↑.
- **Bring Home**: 주요 거점(IXP 등)에 대규모 서버 배치 (Limelight). → 유지보수 용이, 비용↓, 지연은 다소↑.

**캐싱 방식**

- **Pull 방식**: 요청 시 다른 서버에서 가져와 캐싱. 인기 없는 콘텐츠는 자동 삭제.
- **Push 방식**: 미리 CDN 서버로 밀어넣음(넷플릭스).

**DNS Redirection**

- CDN은 DNS 응답을 가로채서 사용자에게 "최적 서버"의 IP를 반환 → 클라이언트가 해당 CDN 서버로 접속.
- 클러스터 선택 기준: 지리적 거리, RTT(지연), 패킷 손실률, 서버 부하 등

### 사례 연구

**넷플릭스**

- AWS 클라우드에서 영상 처리·인코딩 → CDN으로 업로드.
- 자체 CDN 구축 (IXP, ISP 내부에 서버 랙 설치).
- **Push 캐싱**: 매일 인기 콘텐츠를 ISP/IXP 캐시에 미리 배포.
- DNS redirection 대신 자체 소프트웨어가 최적 서버 지정.

**유튜브**

- 구글 자체 CDN 사용.
- 기본적으로 RTT가 가장 낮은 서버 선택, 부하 상황에 따라 다른 서버 배정.
- HTTP 스트리밍 사용, 사용자가 직접 화질 선택.
- **Byte-range 요청**으로 필요한 구간만 다운로드 → 낭비 줄임.

---

## 3.7 소켓 프로그래밍

### 개요

- 네트워크 애플리케이션 = **클라이언트 프로그램 + 서버 프로그램**
- 두 프로세스가 소켓을 통해 메시지를 읽고/쓰면서 통신
- **소켓(Socket)**: 애플리케이션 ↔ 트랜스포트 계층 인터페이스 (네트워크 문)
- 개발자는 애플리케이션 요구사항에 맞게 **TCP vs UDP** 선택

### UDP 소켓 프로그래밍

- UDP: **비연결형**, 단순하고 빠름
- 송신자가 패킷에 **목적지 IP + 포트 번호**를 붙여 전송
- 수신자는 패킷을 받아 **내용 해석 후 처리**

**코드 흐름**

- 클라이언트:
    1. 소켓 생성 (UDP)
    2. 사용자 입력 읽기
    3. `sendto()`로 (메시지 + 목적지 주소) 전송
    4. 서버 응답 수신 → 화면 출력
- 서버:
    1. 소켓 생성 + 포트 번호 바인딩
    2. 무한 루프에서 `recvfrom()`으로 패킷 대기
    3. 받은 데이터 처리 (예: 대문자로 변환)
    4. `sendto()`로 응답 전송

### TCP 소켓 프로그래밍

- TCP: **연결 지향형**, 신뢰성 보장
- 통신 전 **3-way handshake**로 연결 수립
- 서버는 두 종류 소켓 사용:
    - **환영 소켓 (Welcome Socket)**: 클라이언트 연결 요청 대기
    - **연결 소켓 (Connection Socket)**: 특정 클라이언트와 데이터 교환 담당

**코드 흐름**

- 클라이언트:
    1. TCP 소켓 생성
    2. `connect()`로 서버의 IP/포트에 연결 요청
    3. 문자열 입력 후 `send()`
    4. 서버 응답 수신 후 출력
    5. `close()`로 연결 종료
- 서버:
    1. TCP 소켓 생성 + 포트 번호 바인딩
    2. `listen()`으로 연결 대기
    3. `accept()`로 연결 수락 → 연결 소켓 생성
    4. 클라이언트 요청 수신 후 처리 (예: 대문자 변환)
    5. 응답 전송 후 연결 소켓 종료 (환영 소켓은 계속 열려 있음)
